

[toc] 



>原理+实践+问题
>
>[https://time.geekbang.org/column/article/270474](https://time.geekbang.org/column/article/270474)
>《redis 设计与实现》
>
>一些面试题：
>
># https://zhuanlan.zhihu.com/p/427496556 
>
>https://zhuanlan.zhihu.com/p/91539644
>
>* redis 的持久化方式，redis3.0 原生集群和 redis 读写分离+哨兵机制区别
>  redis 做缓存是分布式存的？不同的服务器上存的数据是否重复？guava cache 呢？是否重复？不同的机器存的数据不同

<img src="https://p.ipic.vip/xvm7fv.jpg" alt="image-20220320163522797" style="zoom:30%;" />



# redis概念

Redis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API的非关系型数据库。

传统数据库遵循 ACID 规则。而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 CAP 定理。

# redis支持数据类型有哪些？

Redis支持多种数据结构，包括
字符串（Strings）：key-val
列表（Lists）： 
集合（Sets）、有序集合（Sorted Sets）、
哈希（Hashes）、
位图（Bitmaps）、
超日志（HyperLogLogs）和地理空间索引（Geospatial Indexes）。 

<img src="https://p.ipic.vip/z6b294.jpg" alt="image-20220417161409901" style="zoom:50%;" />

除了基本的数据类型（String、Hash、List、Set、Sorted Set），Redis还提供了一些特殊类型，用于特殊场景的应用。这些特殊类型包括：

1. **HyperLogLog（基数统计）**：用于对大数据流中的元素进行统计计数，特别适用于需要快速计算大数据集的基数（不重复元素的数量）的场景，如大规模流量独立访客数统计、页面UV统计等。
2. **GEO（地理位置位置索引）**：用于存储地理位置坐标信息，并支持距离计算和位置索引，特别适用于需要根据地理位置做附近搜索、位置距离计算的场景，如地理位置打卡签到、附近的人查找等。
3. **Bloom Filter（布隆过滤器）**：用于快速判断一个元素是否可能存在于一个集合中，可以解决缓存穿透、布隆攻击等问题。
4. **Bitmap（位图）**：用于存储大量布尔值，以及支持位运算，用于比特级别的操作，如统计活跃用户、用户在线状态、用户签到等场景。

这些特殊类型提供了一些在特定场景下非常有效的数据结构，能够满足某些特殊需求和提供非常高效的计算和存储方式。根据具体的业务需求，合理地选择这些特殊类型能够为系统的性能和效率带来提升。



# 什么是哨兵机制？主库挂了，如何不间断服务？（star）

> https://www.cnblogs.com/joeymary/p/11492791.html  部署
>
> https://blog.csdn.net/xch_yang/article/details/104019552

- situation

  - 主从模式下，主和其他的从还可以对外提供服务。
  - 主挂掉后，无法进行主从同步，客户端无法写，无法对外提供服务。

- action

  - 哨兵机制：特殊模式下的redis进程，主从实例运行的同时，它也在运行。主要作用监控、选主、通知

    ![image-20220321100904552](/Users/haibingzhang/d/weiyundata/typoradoc/images/e6c9d24ely1h1g4xju2u6j21d60i0gnb.jpg)

  - 监控：监控是指哨兵进程在运行时，==周期性==地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。存在误判情况，如果误判，会进行选主和信息同步，增加不必要的开销，通过哨兵集群来减少误判的机率。

    - 主观客观下线：只有==大多数（n/2+1）==的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，

  - 选主：

    - 第一轮：==优先级最高==的从库得分高。根据用户设置的slave_priority。例如某个从库的内存比较大，就会设置比较高的优先级。

    - 第二轮：和旧主库==同步程度==最接近的从库得分高。从库的 slave_repl_offset 需要最接近 master_repl_offset，代表数据最新。

    - 第三轮：==ID 号小的从库得分高==。每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。目前，Redis 在选主库时，有一个默认的规定：在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。

      ![image-20220321100932528](https://p.ipic.vip/unp2tj.jpg)



# 分布式锁：为什么基于etcd实现分布式锁比Redis锁更安全？专题 

> redlock https://www.cnblogs.com/rgcLOVEyaya/p/RGC_LOVE_YAYA_1003days.html

- situation:从茅台超卖案例看分布式锁要素：==互斥性、安全性；活性；高可用、高性能== 
  
  - SET key value [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX]
  
  - 因此分布式锁的第一核心要素就是==互斥性、安全性==。在同一时间内，不允许多个 client 同时获得锁。
  
  - 这就是分布式锁第二个核心要素，==活性==。在实现分布式锁的过程中要考虑到 client 可能会出现 crash 或者网络分区，你需要原子申请分布式锁及设置锁的自动过期时间，通过过期、超时等机制自动释放锁，避免出现死锁，导致业务中断。
  
    (正确的解决方案应该是通过 LUA 脚本实现 Redis 比较库存、扣减库存操作的原子性（或者在每次只能抢购一个的情况下，通过判断Redis Decr 命令的返回值即可。此命令会返回扣减后的最新库存，若小于 0 则表示超卖）。)
  
  - ==高可用、高性能==。加锁、释放锁的过程性能开销要尽量低，同时要保证高q可用，避免单点故障。
  
- 从这个问题中我们可以看到，分布式锁实现具备一定的复杂度，它不仅依赖存储服务提供的核心机制，同时依赖业务领域的实现。无论是遭遇==高负载、还是宕机、网络分区等故障==，都需确保锁的互斥性、安全性，否则就会出现严重的超卖生产事故。

- 这就是分布式锁第三个核心要素，==高性能、高可用==。加锁、释放锁的过程性能开销要尽量低，同时要保证高可用，确保业务不会出现中断。

- redis分布式锁的问题

  - Redis 是基于==主备异步复制协议==实现的 Master-Slave 数据同步（若 client A 执行 SET key value EX 10 NX 命令，redis-server 返回给 client A 成功后，Redis Master 节点突然出现 crash 等异常，这时候 Redis Slave 节点还未收到此命令的同步）
  - ==主备切换、脑裂是 Redis== 分布式锁的两个典型不安全的因素，本质原因是 Redis 为了满足高性能，采用了主备异步复制协议，同时也与负责主备切换的 Redis Sentinel 服务是否合理部署有关。
  - Redis 作者为了解决 SET key value [EX] 10 [NX]命令实现分布式锁不安全的问题，提出了==RedLock 算法==。它是基于==多个独立的 Redis Master== 节点的一种实现（一般为 5）。client 依次向各个节点申请锁，若能从多数个节点中申请锁成功并满足一些条件限制，那么 client 就能获取锁成功。
  - 但是，它的实现建立在一个不安全的系统模型上的，它==依赖系统时间==，当时钟发生跳跃时，也可能会出现安全性问题。你要有兴趣的话，可以详细阅读下分布式存储专家 Martin 对RedLock 的分析文章，Redis 作者的也专门写了一篇文章进行了反驳。

- etcd

  那么基于 etcd 实现的分布式锁是如何确保安全性、互斥性、活性的呢？

  - 正如我在09中给你介绍的==事务特性==，它由 IF 语句、Then 语句、Else 语句组成。其中在 IF 语句中，支持比较 key 的是修改版本号 mod_revision 和创建版本号 create_revision。
    - 相比 Redis 基于主备异步复制导致锁的安全性问题，==etcd 是基于 Raft== 共识算法实现的，一个写请求需要经过集群多数节点确认。因此一旦分布式锁申请返回给 client 成功后，它一定是持久化到了集群多数节点上，不会出现 Redis 主备异步复制可能导致丢数据的问题，具备更高的安全性。
  - ==Lease(租约) 与锁的活性==
    - 正如在06租约特性中和你介绍的，Lease 就是一种活性检测机制，它提供了检测各个客户端存活的能力。你的业务 client 需定期向 etcd 服务发送"特殊心跳"汇报健康状态，若你未正常发送心跳，并超过和 etcd 服务约定的最大存活时间后，就会被 etcd 服务移除此 Lease 和其关联的数据。
  - ==Watch 与锁的可用性==
    - Watch 提供了高效的数据监听能力。当其他 client 收到 Watch Delete 事件后，就可快速判断自己是否有资格获得锁，极大减少了锁的不可用时间。
  - 核心流程：分布式锁concurrency包的使用和实现，它的使用非常简单，如下代码所示，核心流程如下：
    - 首先通过 ==concurrency.NewSession== 方法创建 Session，本质是创建了一个 TTL 为 10 的 Lease。
    - 其次得到 session 对象后，通过 ==concurrency.NewMutex== 创建了一个 mutex 对象，包含 Lease、key prefix 等信息。
    - 然后通过 ==mutex 对象的 Lock 方法==尝试获取锁。最后使用结束，可通过 mutex 对象的 Unlock 方法释放锁。
  - 那么 mutex 对象的 Lock 方法是如何加锁的呢？
    - 核心还是使用了我们上面介绍的==事务和 Lease 特性==，当 CreateRevision 为 0 时，它会创建一个 prefix 为 /my-lock 的 key（ /my-lock + LeaseID)，并获取到 /my-lock prefix 下面最早创建的一个 key（revision 最小），分布式锁最终是由写入此 key 的 client 获得，其他 client 则进入等待模式。

# redlock原理

原理：Redisson中的RedLock是基于RedissonMultiLock（联锁）实现的。RedissonMultiLock可以同时操作多个锁，以达到对多个锁进行统一管理的目的。联锁的操作是原子性的，即要么全部锁住，要么全部解锁。这样可以保证多个锁的一致性。

废弃原因：RedLock算法存在一些争议和问题，例如<u>性能问题和并发安全性问题</u>。性能问题主要体现在RedLock要等待大多数节点返回之后，才能加锁成功，而这个过程中可能会因为网络问题或节点超时的问题影响加锁的性能。并发安全性问题则可能出现在客户端加锁时，如果遇到GC（垃圾回收）可能导致加锁失效，但GC后误认为加锁成功，从而出现并发安全性问题[➊](https://zhuanlan.zhihu.com/p/676782382)[❻](https://zhuanlan.zhihu.com/p/684186719)。

# 分布式锁有几种：

- 命令setnx + expire分开写
- setnx + value值是过期时间
- set的扩展命令（set ex px nx）
- set ex px nx + 校验唯一随机值,再删除
- Redisson分布式锁实现

# Redisson分布式锁

**分布式锁**可能存在**锁过期释放，业务没执行完的问题**。有些小伙伴认为，稍微把锁过期时间设置长一些就可以啦。其实我们设想一下，是否可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。

当前**开源框架Redisson**就解决了这个分布式锁问题。我们一起来看下Redisson底层原理是怎样的吧：

![image-20240509153515525](https://p.ipic.vip/3ks9ko.png)

只要线程一加锁成功，就会启动一个`watch dog`看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用Redisson解决了**锁过期释放，业务没执行完**问题。

# 哨兵集群：哨兵挂了，主从库还能切换吗？

如果哨兵集群中的哨兵节点挂了，可能会导致以下情况：

- **监控中断**：如果挂掉的哨兵节点负责监控某些主从节点，那么这些节点的监控可能会中断。
- **故障转移延迟**：如果挂掉的哨兵节点是领头哨兵，那么故障转移操作可能会延迟，因为需要重新选举领头哨兵。
- **数据不一致**：如果哨兵集群无法达成一致，可能会导致数据不一致的情况。

为了防止这种情况，建议在部署哨兵集群时遵循以下最佳实践：

- **部署多个哨兵节点**：哨兵集群应该至少包含3个哨兵节点，以确保高可用性。
- **配置合理的`quorum`值**：`quorum`值应该设置为哨兵节点总数的一半以上，以确保故障转移的可靠性。
- **定期检查和维护**：定期检查哨兵节点的状态，并进行必要的维护工作。

如果哨兵节点挂了，应该尽快恢复或替换这些节点，以确保Redis服务的高可用性。在实际操作中，可能需要手动干预来恢复服务，直到哨兵集群恢复正常。



# 案例：12 | 有一亿个keys要统计，应该用哪种集合？

结论：对于五亿个keys的统计，可以选择redis以下结构：

1. BitMaps：keys可以映射到固定的整数范围，方便进行统计。

   适用场景：

   统计具有固定整数范围标识符的 keys 的出现情况。

   计算基数（unique count）、交集、并集、差集等二值状态的统计操作。
   优点：
   极度空间高效：每个 bit 代表一个标识符是否存在，理论上一个亿个标识符仅需约 125MB（1亿 / 8 bits per byte ≈ 125,000,000 bytes ≈ 125 MB）内存。
   高性能：基于位运算的操作（如 AND、OR、NOT）在 CPU 层面非常快，使得计算交集、并集等操作极为高效。
   原子性：Redis 提供了对 Bitmaps 的原子操作，确保在高并发环境下的正确性。
   命令示例：
   SETBIT key offset value 设置指定偏移量的 bit 值。
   GETBIT key offset 获取指定偏移量的 bit 值。
   BITCOUNT key [start end] 计算 key 中值为 1 的 bit 数目。

2. HyperLogLog：只是估算unique keys的数量，允许有一定的误差。

   适用场景：
   统计大量唯一 keys 的近似基数，即估算 distinct key 的数量，允许一定的误差（通常小于 1%）。
   优点：
   极高空间效率：即使面对上亿级别的 keys，HyperLogLog 只需极小的固定内存（约 12KB）。
   无需存储全部 keys：只记录 keys 的散列信息，而非实际 keys，因此非常适合大基数统计且不需要精确值的场景。
   命令示例：
   PFADD key element [element ...] 添加元素到 HyperLogLog 结构。
   PFCOUNT key [key ...] 返回给定 HyperLogLog 的基数估计值，支持多个 HyperLogLog 的合并计数。

如果需要排序、范围查询、分数关联或精确的set操作，可以用以下数据结构：

1. Sorted Sets：带有分数的keys，需要排序和范围统计。

   适用场景：
   当 keys 有分数（score）关联，需要按照分数排序或进行范围查询时。
   统计 keys 在某个分数范围内的情况。
   优点：
   自动排序：根据 score 值对成员进行排序，支持高效地获取 top N 项、分数范围内的成员等操作。
   唯一性保证：同一名成员只能添加一次，避免重复统计。
   丰富的统计功能：通过 ZRANGE, ZREVRANGE, ZCOUNT, ZLEXCOUNT, ZINTER/ZUNION 等命令实现各种统计和聚合。
   命令示例：
   ZADD key score member [score member ...] 添加一个或多个成员及其分数到有序集合。
   ZRANGE key start stop [WITHSCORES] 获取有序集合中指定范围的成员，可选带上分数。
   ZCOUNT key min max 计算有序集合中 score 值在给定范围内的成员数量。

2. Sets：无额外信息的unique keys，进行集合操作。

   适用场景：
   当只需要记录 unique keys，不需要其他附加信息（如分数）时。
   统计 keys 的交集、并集、差集。
   优点：
   高效去重：自动去除重复元素，确保集合内成员唯一。
   快速集合操作：提供 SADD, SREM, SINTER, SUNION, SDIFF 等命令，用于集合间的快速合并、差异计算等。
   命令示例：
   SADD key member [member ...] 向集合添加一个或多个成员。
   SCARD key 返回集合中元素的数量。
   SINTER key [key ...] 返回给定集合的交集。

# redis 如何保证高可靠性

尽量减少数据丢失、尽量减少服务中断。

- 通过AOF和RDB保证数据不丢失。
- 通过增加副本的冗余量来减少服务的中断。将一份数据备份到多个节点 上，即使有一个节点出现故障，其他的节点也能提供数据服务。

# 数据同步：主从库如何实现数据一致？

> 主从库是如何同步的呢？ 是一次性还是分多次？

<img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24egy1h5udwnmjlbj21bk0gugm0.jpg" alt="image-20220417145007153" style="zoom:33%;" />

<img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24egy1h5udwuktn6j21bk0n4t9w.jpg" alt="image-20220417151017809" style="zoom:50%;" />

当我们启动多个redis实例时，主从库通过replicaof命令形成主库和从库(redis5.0之后)，之后会按照三个阶段完成数据的第一次同步：

第一个阶段：<u>建立连接，协商同步</u>。从库向主库发送psync命令，表示要进行数据同步，主库根据这个命令启动复制。psync包含两个参数<u>runID(redis实例启动会被随机分配一个ID)和offset</u>。因为第一次同步不知道主库的runid，所以被设置为“？”，offset为-1。主库接收到请求会用fullReSync命令响应，表示全量复制，返回主库runid和offset.

第二个阶段：<u>主库同步数据给从库</u>，这一步依赖于内存快照产生的rdb文件。主库通过bgsave生成rdb文件并发送给从库，从库接收后先<u>清理掉本地数据</u>，然后加载主库的rdb文件，这是因为可能会有其他的数据影响复制，所以需要先清理数据。由于主库需要一直在对外提供服务，在生成 rdb文件后还会接收写操作。所以为了保证数据的一致性，redis会把写用专用的repl buffer，来记录rdb文件生成 后的写操作。

第三个阶段：<u>主库会把第二阶段生成的写操作再发送给从库</u>。主库发送rdb文件后，就会把复制缓存区（repl_buffer）给从库，从库加载repl buffer完成数据的同步 。

主库一方面进行读写操作一方面进行数据的同步压力过大怎么解决？对于一次全量复制来说，耗时点就是rdb文件的生成和传输。如果从库比较多对主库的压力也会比较大。

可以采用主-从-从的从库级联的模式进行同步，来缓解主库的压力。

<img src="/Users/haibingzhang/d/weiyundata/typoradoc/images/e6c9d24ely1h1crdq38h2j21fm0qewgs.jpg" alt="image-20220417153855213" style="zoom:50%;" />

==主从间网络闪断或网络阻塞如何处理？==

主从网络断开后，主从之间会采用==增量复制==的方式进行同步。当主从断开连接后，主库会把接收到的写操作写入replication buffer中，同时还会写入==repl_backlog_buffer这个缓冲区中==。这是一个环形缓存区，主库会记录自己写到的位置 master_repl_offset，从库会记录自己已经读到的位置slave_repl_offset 。主从恢复连接后，从库发送psync命令与主库建立连接，会带有slave_repl_offset，主库会把master_repl_offset和slave..之间的写操作同步给从库，完成增量复制。

扩展问题：主从断开连接后，在增量同步时从库读取比较慢时，环形缓存会出现覆盖的情况如何处理？

- 一个从库如果和主库断连时间过长，造成它在主库repl_backlog_buffer的slave_repl_offset位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。 
- 每个从库会记录自己的slave_repl_offset，每个从库的复制进度也不一定相同。在和主库重连进行恢复时，从库会通过psync命令把自己记录的slave_repl_offset发给主库，主库会根据从库各自的复制进度，来决定这个从库可以进行增量复制，还是全量复制。

## 内存快照：宕机后，Redis如何实现快速恢复？
Redis通过两种主要的持久化机制来实现数据的持久化和快速恢复：RDB快照和AOF（Append Only File）日志。

- RDB快照（Redis Database）
RDB快照是Redis的一种持久化方式，它会在指定的时间间隔内生成数据集的快照。当Redis宕机后，可以通过RDB快照文件来恢复数据。

- RDB快照的恢复过程：
1.**启动Redis**：首先，启动Redis服务器。
2.**加载RDB文件**：Redis服务器会自动检测到RDB快照文件，并尝试加载它。
3.**恢复数据**：加载RDB文件后，Redis会将文件中的数据恢复到内存中，从而实现数据的快速恢复。

- AOF日志（Append Only File）
AOF日志是另一种持久化方式，它记录了Redis服务器接收到的所有写命令，并在服务器启动时重放这些命令来恢复数据。

- AOF日志的恢复过程：

  1.**启动Redis**：首先，启动Redis服务器。
  2.**重放AOF文件**：Redis服务器会读取AOF文件，并重放其中的命令来重建数据集。
  3.**恢复数据**：通过重放AOF文件中的命令，Redis服务器将数据恢复到内存中。

- RDB与AOF的结合使用

  为了获得更好的数据安全性和恢复速度，Redis允许同时使用RDB和AOF两种持久化方式。在这种情况下，Redis会首先使用AOF日志来恢复数据，因为AOF日志记录了所有写操作，因此可以提供更完整的数据恢复。然后，Redis会使用RDB快照文件来进一步恢复数据，以提高恢复速度。

## 注意事项
- **RDB快照的频率**：RDB快照的生成频率可以通过配置文件中的`save`指令来设置，例如`save 900 1`表示在900秒内至少有1个键发生变化时生成快照。
- **AOF重写**：随着时间的推移，AOF文件可能会变得非常大，因此Redis提供了AOF重写功能来减小文件大小。可以通过`bgrewriteaof`命令手动触发重写，或者配置自动重写策略。
- **持久化配置**：在生产环境中，应该根据数据的重要性、恢复时间目标（RTO）和恢复点目标（RPO）来配置合适的持久化策略。
通过上述机制，Redis可以在宕机后实现快速的数据恢复，确保服务的连续性和数据的完整性。


# 高性能IO模型：为什么单线程Redis能那么快？

>  Redis 线程的三个问题：“Redis 真的只有单线程吗？”“为什么用单线程？”“单线程为什么这么快？”
>
>  Redis 单线程是指它对==网络 IO 和数据读写==的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。
>
>  通常来说，单线程的处理能力要比多线程差很多，但是 Redis 却能使用单线程模型达到每秒数十万级别的处理能力，这是为什么呢？其实，这是 Redis 多方面设计选择的一个综合结果。

- 高效的内存数据结构
  Redis使用内存来存储数据，避免了磁盘I/O的延迟。它使用了高效的数据结构，如哈希表、跳表、压缩列表等，这些数据结构在内存中操作非常快速。

- 优化的网络模型
  Redis使用了基于epoll（Linux）的I/O多路复用技术，它实现了一个线程可以监视多个文件句柄。一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作，而不需要等待前一个操作完成。

- 非阻塞I/O和事件驱动

  Redis使用了非阻塞I/O和事件驱动模型。这意味着当Redis处理一个命令时，它不会阻塞等待I/O操作完成，而是将I/O操作注册到事件循环中，然后继续处理其他命令。当I/O操作完成时，事件循环会通知Redis处理结果。

  

  为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于==事件的回调机制==，即针对不同事件的发生，调用相应的处理函数。

  那么，回调机制是怎么工作的呢？其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。

  <img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h5ue63s18cj216g0u0diu.jpg" alt="image-20220408150035609" style="zoom:50%;" />



# 分布式缓存常用 的方案有哪些？



# redis宕机如何处理
> https://time.geekbang.org/column/article/272852  
Redis宕机可能会对依赖于Redis的应用程序造成严重影响，因此需要采取一系列措施来确保系统的稳定性和数据的完整性。以下是一些处理Redis宕机的策略：
1. 事前：数据备份与恢复
定期将Redis中的数据备份到可靠的存储介质中，如磁盘或云存储。这样，在Redis服务器宕机后，可以使用备份数据进行恢复。例如，可以使用Redis的RDB快照或AOF日志功能来实现数据的持久化。
2. 事前：使用Redis Cluster或Redis Sentinel
使用Redis Cluster可以将数据分布在多个Redis节点上，提供冗余和自动故障转移功能。Redis Sentinel可以监控主节点的状态，并在主节点宕机时进行自动切换。
3. 事前：实时监控与告警
实时监控Redis服务器的状态，包括内存使用、连接数、性能指标等。可以使用监控工具或脚本来收集和分析这些数据，并设置告警机制，以便在服务器出现异常时及时得到通知。
 4. 事中：容错设计与降级
在应用程序中设计容错机制，当Redis无法正常工作时，可以采取降级措施或使用备用数据源。例如，将数据暂时存储在本地缓存或其他可靠的存储中，直到Redis服务器恢复。
5. 事前测试与演练
定期进行故障模拟和恢复演练，以验证备份恢复流程和容错机制的有效性。这有助于发现可能存在的问题并及时改进。
6. 事前：使用Redis的持久化策略
配置Redis以启用数据持久性选项，如RDB快照或AOF日志。这将有助于在服务器宕机后恢复数据。 7. 考虑使用Redis的高可用性解决方案
例如，使用Redis Sentinel进行故障检测和自动故障转移，或者使用Redis Cluster进行数据分片和负载均衡。
8. 事前：数据一致性保障
在分布式系统中，确保数据的一致性是非常重要的。可以使用分布式事务或最终一致性模型来处理跨多个服务和数据库的数据操作。
9. 事前：业务逻辑的容错处理
在应用程序的业务逻辑中加入错误处理和重试机制，以应对Redis服务不可用的情况。
10. 事前：与Redis服务提供商的沟通
如果Redis服务是通过云服务提供商提供的，与服务提供商保持沟通，了解他们的服务SLA和宕机恢复策略。
通过综合运用以上措施，可以提高系统的可靠性和容错能力，减少Redis服务器宕机对业务的影响。具体的实现方式应根据实际情况进行选择和调整，以满足系统的需求和可用性要求[➊](https://blog.csdn.net/love7489/article/details/137098605)。


Redis哨兵部署模式和Redis集群部署模式是两种常见的Redis高可用部署方案，它们各有优势适用于不同的场景。

1. **Redis哨兵部署模式**：
   - 优势：适用于主从复制的高可用部署场景。当主节点故障时，哨兵能够自动选举出一个新的主节点，保证Redis服务的可用性，同时也支持读写分离，能够提升整体的读写性能。
   - 不足：不能横向扩展，主从复制的架构会导致主节点的性能瓶颈，并且故障恢复时间可能稍长。
2. **Redis集群部署模式**：
   - 优势：适用于大规模高可用的分布式场景。集群模式能够横向扩展，分散了数据存储和处理压力，提供了更高的性能和容量。同时也支持自动分片和数据平衡。
   - 不足：不支持事务（MULTI/EXEC）、Pub/Sub命令（PUBLISH/SUBSCRIBE），并且需要客户端进行分片计算和路由转发。

目前，Redis集群部署模式在<u>大规模高可用</u>分布式场景下更加广泛应用。随着互联网规模的不断扩大，对于大容量和高性能的需求日益增长，Redis集群部署模式作为横向扩展的解决方案，能够提供更好的性能和可扩展性，并且逐渐成为主流。

然而，对于<u>小规模和中规模</u>的场景，特别是对主从复制和读写分离有需求的场景，Redis哨兵部署模式仍然是一个成熟且广泛使用的解决方案。


# 京东一面：Redis 如何实现库存扣减操作？如何防止商品被超卖？

1. 使用原子操作
在Redis中，使用`DECR`或`DECRBY`命令可以原子性地减少库存数量，从而防止超卖。这些命令在Redis内部是原子的，即使在高并发情况下也能保证库存数量的准确性。
2. 使用Lua脚本
对于更复杂的库存扣减逻辑，可以使用Lua脚本来确保多个操作的原子性。例如，您可以编写一个脚本来检查库存是否足够，然后执行扣减操作。
3. 分布式锁
在分布式系统中，使用分布式锁可以确保同一时间只有一个进程可以修改库存。这可以通过Redis的`SETNX`命令或使用Redisson等客户端库来实现。
 4. 事务
虽然Redis的事务（MULTI/EXEC）不提供原子性操作，但可以用来组合多个命令，以确保它们作为一个单元执行。例如，您可以使用事务来确保在扣减库存之前检查库存是否足够。
5. 最终一致性模型
在某些情况下，可以接受短暂的超卖情况，然后通过后续的补偿操作来解决。例如，如果订单处理系统检测到超卖，它可以取消订单或通知客户库存不足。
6. 预先检查库存
在用户将商品添加到购物车时，预先检查库存数量，确保用户看到的是准确的库存信息。
 7. 限制并发请求
通过限制对库存扣减接口的并发请求，可以减少超卖的风险。这可以通过限流器（如Guava RateLimiter）或使用分布式限流系统（如Sentinel）来实现。
 8. 使用消息队列
在高并发场景下，可以使用消息队列来处理库存扣减请求。这样可以将请求放入队列中，然后逐个处理，确保每个请求都有机会被处理。
9. 监控和告警
实时监控库存扣减操作，并设置告警机制。如果检测到库存数量异常，立即采取措施。
10. 定期库存校验
定期进行库存校验，确保系统中的库存数量与实际库存数量一致。
11. 使用数据库事务
如果您的应用程序使用关系型数据库来管理库存，确保在扣减库存时使用数据库事务来保持数据的一致性。
通过上述策略的组合使用，可以有效地防止商品超卖。在实施这些策略时，需要根据您的具体业务需求和系统架构来选择最合适的方法。

# 什么是缓存击穿、缓存穿透、缓存雪崩？ 



# 什么是热Key问题，如何解决热key问题 



## # Redis 过期策略和内存淘汰策略 

## # 说说Redis的常用应用场景 

- 缓存
- 排行榜
- 计数器应用
- 共享Session
- 分布式锁
- 社交网络
- 消息队列
- 位操作

# MySQL与Redis 如何保证双写一致性 

## 缓存延时双删

延时双删流程

1. 先删除缓存
2. 再更新数据库
3. 休眠一会（比如1秒），再次删除缓存。

这个休眠一会，一般多久呢？都是1秒？

> 这个休眠时间 =  读业务逻辑数据的耗时 + 几百毫秒。为了确保读请求结束，写请求可以删除读请求可能带来的缓存脏数据。

这种方案还算可以，只有休眠那一会（比如就那1秒），可能有脏数据，一般业务也会接受的。但是如果**第二次删除缓存失败**呢？缓存和数据库的数据还是可能不一致，对吧？给Key设置一个自然的expire过期时间，让它自动过期怎样？那业务要接受过期时间内，数据的不一致咯？还是有其他更佳方案呢？

## 删除缓存重试机制

因为延时双删可能会存在第二步的删除缓存失败，导致的数据不一致问题。可以使用这个方案优化：删除失败就多删除几次呀,保证删除缓存成功就可以了呀~ 所以可以引入删除缓存重试机制

![image-20240509154129617](https://p.ipic.vip/0u48xa.png)

删除缓存重试流程

1. 写请求更新数据库

2. 缓存因为某些原因，删除失败

3. 把删除失败的key放到消息队列

4. 消费消息队列的消息，获取要删除的key

5. 重试删除缓存操作

   



## 读取biglog异步删除缓存

重试删除缓存机制还可以吧，就是会造成好多**业务代码入侵**。其实，还可以这样优化：通过数据库的binlog来异步淘汰key。

![image-20240509154243920](https://p.ipic.vip/ijx8x1.png)

以mysql为例吧

- 可以使用阿里的canal将binlog日志采集发送到MQ队列里面
- 然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性



# 为什么Redis 6.0 之后改多线程呢？ 

- Redis6.0之前，Redis在处理客户端的请求时，包括读socket、解析、执行、写socket等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。
- Redis6.0之前为什么一直不使用多线程？使用Redis时，几乎不存在CPU成为瓶颈的情况，  Redis主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。

redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。

这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。

# 聊聊Redis 事务机制 

Redis通过**MULTI、EXEC、WATCH**等一组命令集合，来实现事务机制。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

简言之，Redis事务就是**顺序性、一次性、排他性**的执行一个队列中的一系列命令。

Redis执行事务的流程如下：

- 开始事务（MULTI）
- 命令入队
- 执行事务（EXEC）、撤销事务（DISCARD ）

# others

7. redis6.0 以后为什么引入多线程？
8. redis 如何判断数据是否过期的?
9. 过期的数据删除策略了解吗？
10. redis 内存淘汰机制指的是什么？
11. redis 的持久化机制是什么样的？如何保证 redis 挂掉后重启进行修复 ？
12. redis 的事务？
16. raft协议指什么？  
17. 缓存热key

