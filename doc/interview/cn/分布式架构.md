

[toc]

# 分布式架构的问题

- 应用服务拆分
- 分布式调用
- 分布式协同
- 分布式计算
- 分布式存储 
- 分布式资源管理和调度
- 高性能与可用性

# 分布式应用服务的拆分

参见DDD

# 分布式调用

参见微服务治理、调用

## 负载均衡

## API网关

## 服务注册和发现

## 服务间的远程调用

# 分布式协同

## 分布式系统的特性与互斥

## 分布式锁

## 分布式事务

### ACID理论

- atomic : 原子性是指事务操作要么都成功，要么不执行，不会存在中间状态。如果事务中有一个操作不成功，那么整体都要回滚。
- consistency：一致性是指事务执行前后数据是一致的。比如转账操作。
- isolation：隔离性是指一个事务内部操作对数据的更改不会影响其他事务。
- duration：持久性是指事务操作完成后，此操作对数据状态的更新会永久保存下来。

### CAP理论

> CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。
> 因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：如果不保证分区容错性，就放弃了分布式。

- consistency：强一致性。一致性是指分布式系统中所有的数据在同一时刻是一致的。比如数据库的两个节点获取数据时是一致的。
- avalible：可用性是指即使分布式系统出现部分节点不可用，系统仍然可以对外提供读写服务。
- partition ：分区容错性是指分布式系统出现网络问题，产生了分区的情况，那么就需要在一致性和可用性之间做出选择。是保证一致性，等数据同步后再获取数据。还是保证可用性，只获取一个分区的数据？
- CAP无法兼顾三个特性，同一时刻只能保证两个：因为分布式系统中服务和应用分布在不同的网络，所以必须保证分区容错性，只能在一致性和可用性之间做出选择。
- AP：保证可用性和分区容错性。 说明注重用户体验，这种场景多是toC的应用，例如高并发的toC应用电商系统。
- CP：保证一致性和分区容错性。 说明系统对数据一致性要求比较高，常见于金融系统，即使牺牲了用户体验，也要保证交易数据的一致性。

- CA 传统Oracle数据库
AP 大多数网站架构的选择  zk
CP Redis、Mongodb
注意：分布式架构的时候必须做出取舍。

### BASE理论

> BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。

- basic avaliable：基本可用是指即使系统部分节点出现故障，也可以通过降级、限流的方法保证系统的可用。
- soft state：软状态是指数据会包含多个副本，副本间存储着同步延迟。未完成同步时叫做软状态。
- Eventually consitency：最终一致性是相对强一致性而言的，后者是保证所有数据都是一致的，是实时同步。前者可容忍一小段时间的数据不一致，这段时间过后数据必须一致。

### 分布式事务2PC解决方案

- 

### 分布式事务TCC解决方案

- Try 阶段完成的工作是预定操作资源（Prepare），说白了就是“占座”的意思，在正式开始执行业务逻辑之前，先把要操作的资源占上座
- Confirm 阶段完成的工作是执行主要业务逻辑（Commit），它类似于事务的 Commit 操作。在这个阶段中，你可以对 Try 阶段锁定的资源进行各种 CRUD 操作。如果 Confirm 阶段被成功执行，就宣告当前分支事务提交成功。
- Cancel 阶段的工作是事务回滚（Rollback），它类似于事务的 Rollback 操作。在这个阶段中，你可没有 AT 方案的 undo_log 帮你做自动回滚，你需要通过业务代码，对 Confirm 阶段执行的操作进行人工回滚。



## 分布式选举

### 强一致性和弱一致性

强一致性算法：paxos（google chubby分布式锁）、raft(etcd,nacos)、zab(zookeeper)

弱一致性算法：DNs系统、gossip协议(carsendard)、



### Raft算法

raft算法是一个去中心化的算法，遵循少数服务多数的原则。分为三个角色：leader、candidate、follower。

- leader选举过程：
  - 初始化：集群初始化时，所有的节点都为follower，集群中没有领导者。如果存在领导者，会定时向follower发送心跳信息。
  - 选举超时控制机制：由于集群中没有leader，需要进行选举。集群中的所有节点从follower转化为cadidate，同时向其他节点发送选举请求。这里有一个选举超时控制机制（election timeout）,用来控制follower转化为cadidate的时间，一般为150-300ms的一个随机数。
  - 进行选举：因为有选举超时控制机制，其他节点接收到请求是有先后顺序的，接收到请求的节点回复请求发起者是否同意其成为领导者。需要注意的是每轮选举中，每个节点只能投出一票。
  - 选举结果：如果有候选者收到超过一半的选票，那么这个候选者就会成为leader并宣布自己的任期。任期可以理解一个累加的数字，第一次选举任期为1。领导者宣布任期后其他的节点会转变为跟随者。领导者会向其他的节点发送自己的心跳包，检测对方是否存活。
  - 网络延时或死机：当领导者出现网络延时或宕机时，无法发送心跳，跟随者在超时时间内接收不到领导者的心跳时就会发生选举，这时领导者降级为跟随者，跟其他的跟随者一起选举。

- 领导者写入过程：
  - 领导者接收到客户端的写入请求，在本地日志创建一条entry日志记录这次修改。注意是未未提交状态，也就是说还没有领导者节点更新信息。
  - 领导者把写入信息发送给跟随者，跟随者接收到信息后给领导者确认信息。直到收到一半以上的确认信息后，领导者才会将写入的信息提交到本地日志。与此同时，领导者会向集群所有的跟随者发送心跳时发送appendentries，声明这次更改已经提交。通知全网并得到确认的过程称为日志复制。

- 如果出现脑裂现象：会根据任期大小 确认leader节点，以任期大的leader节点为准 。



### zab算法

### zookeeper

参见zookeeper



# 分布式计算

## mapreduce模式



## stream模式



# 分布式存储

## 分布式数据库

## 分布式缓存

# 分布式资源管理与调度



## 资源划分与调度策略

## 分布式调度架构

## 资源调度实践--kubernetes



# 高性能与可用性



## 缓存的应用

## 可用性

# 架构设计思路与要点