



[toc]

>说明：本文包含mysql待解决问题、原理部分、面试部分、案例部分、书籍和实践部分
>
>sql的执行过程；索引存储结构及原理；
>核心问题：
>
>1. B+索引的优势 
>2. 索引的实现
>性能调优：
>mysql调优之（sql语句：高性能sql语句、事务：高并发场景下事务调优、索引：索引失效与优化）；避免死锁；分库分表的时机；电商表调优案例；db参数设置

# todo

- Tidb   

-  https://blog.csdn.net/qq_32447301/article/details/110506715  

  https://docs.pingcap.com/tidb/stable/quick-start-with-tidb

  

# 一、mysql数据库索引是如何实现的

1. **问题** 
* 数据库索引是如何实现的？
* 底层是什么样的数据结构？
2. 算法解析
* 定义清楚问题（对一些模糊的需求进行假设，来限定要解决的问题范围）
    * 查找某个数据  select * from user where id=1234；
    * 根据区间查找数据 select * from user where id > 1234 and id < 2345。
* 尝试用学过的数据结构解决这个问题
    * 支持快速查找、插入、删除的数据结构**散列表、平衡二叉树、跳表**
    *  `散列表` 的查询性能好，时间复杂度为**O(1)**，但不支持区间查询
    *  `平衡二叉树` 查询性能好，时间复杂度为**O(logn)**，根据中序遍历，可以得到一个**从小到大有序的数据序列**。但仍不支持区间的快速查找。
    *  `跳表` 是在链表之上加上**多层的索引**结构构成的，支持**快速查找、插入和删除**，对应的**时间复杂度为O(logn)**，并且跳表也支持按照区间快速的查找数据。跳表是可以解决问题的。实际上数据库的索引结构与跳表非常相似，是B+树，不过它是从二叉查找树演化而来的。
    <img src="https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h14d031uytj21rt0u0whz.jpg" alt="image-20220410091657560" style="zoom:30%;" />

3. 解决方案
* B+树作为索引，由二叉查找树演化。改造二叉查找树来解决问题。
    * 树中的节点不存储数据本身，而只是作为索引。
    * 把每个叶子节点串在一个链表上，链表中的数据从小到大有序排列。
      ![image-20220410091717245](https://i0.wp.com/tva1.sinaimg.cn/large/e6c9d24ely1h14d4qej3pj21fr0u0god.jpg)
    
4. 内存占用多怎么解决？
* 为上千万、上亿的数据建立索引，如果将索引存在在内存中，尽管内存查找非常快，但占用内存会非常多。
* 为一个上亿的表构建二叉查找树索引，索引中会包含大概1亿个节点，每个节点16个字符，需要1G的内存空间。
* 解决方案：借助时间换空间(牺牲时间)的思路，把索引存储在硬盘上，而非内存。这样就降低了内存的占用，但硬盘的访问速度是ms级的，同时也**降低了查询的效率。**
5. 查询效率低下如何解决？
* 把树存储在硬盘中，每次节点的读取，都对应一次磁盘IO。树的高度就是每次查询磁盘的io的次数。
* 磁盘io是非常耗时的，所以优化重点就是降低磁盘io，也就是降低树的高度。
6. 如何降低树的高度？
* 把二叉树变成m叉树，树的高度就会降低。磁盘io次数就会减少，查询效率就会提升。
* 那m是不是越大越好呢？ 不是。  
* 磁盘或内存都是按页读取数据的，如果大于一页，那就会触发多次io。所以在选择m大小时，尽量每个节点都是一页的大小（m值）。那读取一个节点，只需要一次磁盘io。
  ![image-20220410091804600](https://tva1.sinaimg.cn/large/e6c9d24ely1h14d18sl1sj214m0u0q5v.jpg)

7. 索引越多越好吗？有利有弊
* 数据的写入会涉及**索引的更新**，导致数据写入变慢。
* 每个节点最多m个子节点，写入会导致子节点增多，节点数超过m就会产生多次磁盘io，降低查询效率。
* 如何解决：我们将这个节点分裂成两个节点，节点分裂后上层的节点可能超过m，上层再进行分裂，一直影响到根节点。
* 删除同上，解决方案是合并节点，设置阈值m/2，节点数小于阈值，进行合并。
  

![image-20220410091828934](https://tva1.sinaimg.cn/large/e6c9d24ely1h14d1kfi74j214e0u0gom.jpg)

8. B+树的特点总结
* 每个节点中子节点的个数不超过m，也不能小于m/2
* 根节点的子节点个数可以不超过m/2，这是一个例外
* m叉树只存储索引，并不真正存储数据，有点类似跳表。
* 通过链表将叶子节点进行串连，有利于区间查询
* 一般情况下，根节点保存在内存中，其他节点保存在磁盘中。

# 二、面试题

## myISAM与InnoDB区别？

1. **是否支持行级锁**：MyISAM只支持表级锁(table-level-locking)；InnoDB支持表级锁和行级锁(row-level-locking)
2. 是否**支持事务和崩溃后的安全恢复**：
    1. MyISAM存储引擎强调的是性能，每次查询具有原子性，性能比InnoDB更快，但不支持事务。
    2. InnoDB存储引擎支持ACID事务，外部键等高级数据库功能。具有事务、回滚、崩溃后安全恢复能力。
3. **是否支持外键**：MyISAM不支持，InnoDB支持外键
4. **是否支持MVCC**：仅InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效；MVCC只有read commit 和repeatable read两种隔离级别下工作；MVCC可以使用乐观锁和悲观锁来实现，各个数据库的MVCC实现并不统一。

## 什么是事务

事务是逻辑上的一组操作，要么都执行，要么都不执行。事务最经典的例子就是转账。

## 事务的四大特性ACID

* atomic
* consistency
* islation
* Duration

##  并发事务带来的问题

在典型的应用程序中，多个用户经常操作相同的数据来完成各自的任务。并发虽然不是必须的，但可以导致以下 的问题

1. 脏读：
2. 丢失修改：
3. 不可重复读：
4. 幻读：

##  事务的隔离级别都有哪些？MySQL默认的隔离级别是什么？

Read uncommit,read commit, repeatable read, serilizable

* 基本概念
* mvcc原理
* mysql repeatable原理

## 7. 锁机制和InnoDB的锁算法：表级锁和行级锁的对比？InnoDB的锁算法有什么？

* 概念、原理、实例、myisam  vs innodb。

## 9. 解释一下什么是池化思想？什么是数据库连接池？为什么要用连接池？

## 10. 分库分表后主键id如何处理？

## 11. 一条sql在mysql中是如何执行的

## 15. 什么是MVCC？实现原理是什么样的？ （//todo 需要更新）

> Innodb的MVCC是通过保存快照来实现的。当前读和快照读

**定义**：多版本并发控制，读取数据时通过一种==类似快照==的方式把数据保存下来，这样读锁和写锁就不会产生冲突了。不同的事务session会看到自己特定版本的数据：版本链。

**场景**：MVCC只是在read commit(RC) 和repeatable(RR)两种隔离级别下工作，其他的两种隔离级别与MVCC不兼容。因为read uncommit总是读取最新的数据行，无法读取符合事务版本的数据行。而serializable会对所有读取的行都加锁。

**聚簇索引**记录中有两个必要的隐藏列：

**Trx_id**：用来记录修改==聚簇索引事务==的事务id。

**Roll_pointer**：每次对聚簇索引有修改的时候，都会把老版本==写入到**undo日志==**中。这个roll_pointer用于**保存指针，它指向了聚簇索引的上一个版本的位置，通过它来==获取上一个版本==的信息。（注意插入操作的undo日志没有这个属性，因为它没有上一个版本）

Read commit 和 Repeatable read 区别就在于他们生成ReadView的策略不同。

**原理**：开始事务时创建**ReadView**，readview 维护==当前活动的事务id==，即未提交的事务id，==排序生成一个数组==。访问数据时，获取数据中的**事务中id**（获取的是事务id最大的记录），对比ReadView：事务id vs readview

* 如果在readview的左边（比readview都小），可以访问数据（说明事务已经提交）
* 如果在readview的右边（比readview都大）或者在readview中，不可访问。获取roll_pointer，获取上一版本重新对比（右边意味着该事务在readview出现后创建，在readview中意味着该事务还未提交）
**read commit隔离级**别在每次查询时都会创建一个独立的readview，而**repeatable隔离级别**在第一次读的时候生成一次readview，之后的读复用这次生成的readview。（repeatable性能好的原因）

总结：这就是Mysql的MVCC，通过版本链实现多版本，可实现并发读写，写读。通过readview生成的**策略不同实现不同的隔离级别**。

[mvcc](https://www.bilibili.com/video/BV1Eb4y1R7zd?p=64)

![image-20220410091849623](https://tva1.sinaimg.cn/large/e6c9d24ely1h14d1xfqz2j21t60rs76y.jpg)

​      


## 16. 索引类型有什么？什么是聚簇索引？
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h14d26p9h6j21390u0tc3.jpg" alt="image-20220410091905583" style="zoom:33%;" />



聚簇索引就是按照每张表的==主键==构造一棵B+树，同时叶子节点中存放的就是**整张表的行记录数**据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表**只能拥有一个**聚簇索引。
优点：
1.数据**访问更快**，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
2.聚簇索引对于**主键的排序查找和范围查找速度**非常快
缺点：
1.插入速度严重**依赖于插入顺序**，按照主键的**顺序插入**是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增的ID列为主键**
2.**更新主键的代价很高**，因为将会导致**被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。
3.**二级索引访问需要两次索引查找**，第一次找到主键值，第二次根据主键值找到行数据。

辅助索引（非聚簇索引）
　　在**聚簇索引之上创建的索引称之为辅助索引**，辅助索引访问数据总是需要**二次查找(回表)**。辅助索引**叶子节点**存储的不再是行的物理位置，而是**主键值**。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。

## 17. mysql主从同步的原理

mysql主从同步的过程：
mysql主从同步主要有三个线程：master（binlog dump thread），slave（I/O thread，sql dump thread）。master的一条线程和slave的两条线程。

* **主节点的binlog**：主从同步的基础是主库记录所有的变更到binlog。binlog是数据库服务启动那一刻起，保存所有修改数据库结构和内容的一个文件。
* **主节点的binlog dump线程**：当binlog有变动时，log dump线程读取其内容发送给从节点。
* **I/O线程**：从节点I/O线程接收到binlog后，将其内容写入到rely log（中继日志）文件中。
* **sql dump 线程**：从节点sql dump 线程读取rely log内容对数据更新进行重放，最终保证主从数据库一致性。
注意：主从节点通过**binlog文件+position位置**来定位主从同步的位置，从节点会记录已接收到的偏移量。如果从节点发生宕机重启，则自动会从position的位置发起同步。（所以mysql主从同步是增量同步）

**问题**：由于mysql默认的**复制方式是异步**的，主库把日志发送给从库后不关心从库是否处理成功。这样会产生一个问题就是假设**主库挂了**，从库**处理失败**，这个时候从库升级为主库，日志就丢失了。由此产生两个概念：

* **全同步复制**：主库写入binlog后**强制同步日志**到从库，所有的从库都处理成功再返回客户端 ，但是很显然这种方式的话性能会受到严重的影响。
* **半同步复制**：与全同步复制不同，半同步的逻辑是这样的。从库写入日志成功后返回ACK确认给主库，主库收到**至少一个从库**的确认就认为写操作成功。

## 20. B树与B+树区别

* ==查询效率== ：B+树节点内不存储数据， 所有数据存储在叶子节点，查询时间复杂度固定为O(logn)。而B树节点存储数据，查询时间时间复杂度与 key在树中位置有关 ，最好为O(1)。
* ==范围查询==：B+树叶子节点以链表形式组织，增加了区间的访问性，可以进行范围查询。而B树节点key和数据在一起，无法进行范围查询。
* ==索引范围==：B+树更适合外部 存储 ，由于节点内无数据，每个节点能索引的范围更大。

数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，(由于节点中有两个数组，所以地址连续)。


## mysql回表指什么？如何避免？

回表操作是指==回到主键索引树==搜索的过程。

- 回表操作（Row Lookup）是指在使用索引进行查询时，如果索引中不包含查询所需的所有数据列，数据库需要从索引中获取数据行的主键或唯一标识符，然后根据这些标识符去表中查找完整的数据行，这个过程称为回表。

  为了减少回表操作，可以考虑以下策略：

  - **索引覆盖**：设计索引时，尽量包含查询中需要的所有列。
  - **索引合并**：如果查询需要多个索引，可以考虑使用索引合并来减少回表操作。
  - **索引选择性**：选择性高的列应该放在索引的前面，以提高索引的效率。

例如：先搜索amount 索引树得到主键，再通过主键索引树搜索行记录，因为所要查询的数据只在主键索引上有，所以不得不回表。

``` java 
select * from order where amount between 100 and 200;  -- (id primary key, amount index)
```
如何优化：
- 使用覆盖索引进行优化。由于覆盖索引可以减少树的搜索次数，是一种常用的优化手段。索引已经覆盖了我们的查询城需求，这样的索引称为覆盖索引。
``` sql
select id from order where amount between 100 and 200;
```

## 最左前缀原则

B+树这种索引的数据结构，可以利用索引的“==最左前缀==”来定位记录。最左索引可以是联合的N个字段，也可以是一个字段的N个字符。“where name like 'a%'” 也能利用上索引。

==索引下推优化：==
mysql5.6引入了索引下推优化，就是可以在索引遍历过程中，对索引中包含的字段进行判断，直接过滤掉不满足条件的记录，减少回表的次数。

``` sql
select * from tuser where name like '张%' and age = 10 and ismale = 1;
idx_name_age(name, age)  先对age=10进行判断，过滤掉不满足条件的记录。
```



## mysql中using index、using where、using index condition的区别

- using index：表示使用了覆盖索引

- using where：表示在查找使用索引的情况下，需要回表操作查询数据

- using index condition：表示查找使用了索引，不需要回表操作，因为要过滤的字段在索引中

- using index & using where：表示查找使用了索引，要查询的字段都在索引中，不需要进行回表操作（在联合索引中经常出现这样的情况）

  https://blog.csdn.net/liujiqing123/article/details/120688295



## 有一个查询where后面是三个索引字段，这三个索引都会用到吗？

``` sql
select * from test where name='zhangsan' and age=11 and tall = 110;
# index:name, age,tall
```

explain sql：

![image-20220908084807399](https://tva1.sinaimg.cn/large/e6c9d24egy1h5ywqm9f49j21ss02mt9i.jpg)

![image-20220908220117416](https://tva1.sinaimg.cn/large/e6c9d24ely1h5zjnuk68ij21zk04iab9.jpg)

type：ref  or   index_merge

key：索引字段用到了idx_name   or idx_name,idx_age

possible_keys：可能用到的索引是三个

extra：using where 



## 多列索引

- 对where后的字段都建立独立索引，查询效率不一定高。为多个列建立独立索引，最多也只能是“一星”索引，比真正的优化索引差几个数量级。那不如集中优化索引的顺序或创建一个全覆盖索引。

- 索引合并（index_merge）：

  - 优势：mysql5及以上引入了索引合并策略，会同时扫描多个独立的索引列。

  - 劣势：索引合并是优化器优化的结果，出现这种情况说明索引建的比较糟糕。

    - 当服务器需要多个索引进行and相交操作时，一般是需要建立覆盖索引
    - 当服务器需要多个索引进行or联合操作时，通常需要耗费大量的cpu和内存资源进行

  - 解决方法：

    - 根据执行计划查看索引类型是不是index_merge，如果是的话优化表结构或查询语句。
    - 可以通过opimizer_switch关闭索引合并，也可以使用ignore index提示优化器优化掉某些索引。

    

## 如何选择合适的索引顺序

- 经验法则：在不考虑排序、分组和范围查询的条件下，将选择性最高的列放到索引最前列（列/基数）

![image-20220908224440359](https://tva1.sinaimg.cn/large/e6c9d24ely1h5zkwztbctj20zs0bwwh9.jpg)

# 三、数据库性能调优

> 问题：无索引、索引失效、锁等待（死锁、锁升级）

<img src="/Users/haibingzhang/d/weiyundata/typoradoc/images/image-20220329192552661.png" alt="image-20220329192552661" style="zoom:33%;" />

优化思路：//todo



## ==应用层==：

- ==减少对数据库调用==。这里主要从功能的实现方案或架构设计角度，减少一些不合理的设计。比如某些数据库的调用可以从功能上进行合并，或者转化成批量形式、或是加入缓存。
- ==应用主从读写分离==，减轻主库的读写压力，提高查询效率。

## ==数据库本身==：

预先设置（缓存池的大小）、多线程管理（kill不必要的线程）

## ==高性能的事务==

- ==避免行锁升级为表锁==：行锁通过索引实现的，如果不通过索引检索数据，就会升级为表锁，严重影响表的操作性能。
- ==控制事务的大小==，降低资源的锁定粒度，减少资源的锁定时间。
- 结合业务场景，使用低==级别的事务隔离级别==：用户登陆时间的更新可用低级别的事务隔离级别；用户余额或积分，存在在并发情况，必须使用RR隔离级别。

## ==高性能索引==

> 根据慢查询进行explain分析
>
> https://www.toutiao.com/article/7122345201695212064/?log_from=aeac4eb12fcac_1661217631122    //待梳理 

- ==创建索引==：如何一个简单的==where子句==查询返回的时间太长，则可以判定查询的列是需要索引的。  //参照索引原则（todo） 
- ==自增字段作为主键优化查询==：在插入数据时，同一个叶子节点的数据顺序是按主键的顺序存储的，不需要移动已有数据，效率非常高。
- ==避免索引失效==：全值匹配、精准匹配某一列范围匹配另一列、最左前缀  
  - 失效情况：//todo https://blog.csdn.net/GuoWangWang11/article/details/125739859
- ==避免回表操作==：加入覆盖索引、索引最左前缀原则 、mysql5.6优化 （索引MRR、索引下推），
- ==聚合查询==：MySQL使不使用索引与所查列无关，只与==索引本身，where条件，order by 字段，group by 字段有关==。索引的作用一个是查找，一个是排序。（//todo）

扩展：

- 最左原则：MySQL索引的最左原则（Leftmost Prefix Principle）是指在使用复合索引时，查询优化器会根据索引定义的顺序来使用索引中的列。只有当查询条件中包含了复合索引的最左边的列时，索引才会被使用。

- 回表操作（Row Lookup）是指在使用索引进行查询时，如果索引中不包含查询所需的所有数据列，数据库需要从索引中获取数据行的主键或唯一标识符，然后根据这些标识符去表中查找完整的数据行，这个过程称为回表。

  为了减少回表操作，可以考虑以下策略：

  - **索引覆盖**：设计索引时，尽量包含查询中需要的所有列。
  - **索引合并**：如果查询需要多个索引，可以考虑使用索引合并来减少回表操作。
  - **索引选择性**：选择性高的列应该放在索引的前面，以提高索引的效率。

### 索引的优缺点

**优点**

- 提高查询语句的执行效率，减少 IO 操作的次数
- 创建唯一性索引，可以保证数据库表中每一行数据的唯一性
- 加了索引的列会进行排序，在使用分组和排序子句进行查询时，可以显著减少查询中分组和排序的时间

**缺点**

- 索引需要占物理空间
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
- 当对表中的数据进行增删改查时，索引也要动态的维护，这样就降低了数据的更新效率

### 索引的设计原则

> https://www.toutiao.com/article/7122345201695212064/?log_from=aeac4eb12fcac_1661217631122

### 索引优化之 MRR

> Multi Range Read(MRR) 多返回查询。

- select* user from table where age > 18
- mysql5.6会先查询 age>18放入缓存，再进行回表
- mysql5.5查询出多条进行单条回表

### 索引下推

- 假设有索引(name, age), 执行 SQL: select * from tuser where name like '张%' and age=10;
- MySQL 5.6 以后， 存储引擎根据（name，age）联合索引，找到，由于联合索引中包含列，所以存储引擎直接在联合索引里按照age=10过滤。按照过滤后的数据再一一进行回表扫描。

## ==高性能的SQL==

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h38qdotsplj20uw0u00w6.jpg" alt="image-20220329192552661" style="zoom:33%;" />



### ==常用分析方法==

- ==执行计划==：通过explain分析sql的执行计划，关注一些关键字段
  - type：const、ref、index、all
  - Key：索引列
  - rows：扫描行数是否扫描的额外的记录
  - Extra:using where or using index
- ==show profile==：通过show profile分析mysql内核的运行情况，通过执行线程的状态和时间上分析
- ==OR关键字==：如果查询中有复杂的or条件，可以用子句的union代替，会极大提升性能
- ==Like关键字==：like很慢，最好用fulltext代替。

```
尽量避免使用子查询
用 IN 来替换 OR
读取适当的记录 LIMIT M,N，而不要读多余的记录
禁止不必要的 Order By 排序
总和查询可以禁止排重用 union all
避免随机取记录
将多次插入换成批量 Insert 插入
只返回必要的列，用具体的字段列表代替 select * 语句
区分 in 和 exists
优化 Group By 语句
尽量使用数字型字段
优化 Join 语句
```



###  ==优化数据访问==

- ==select *== : 避免向数据库请求不需要的数据：==select \*==: 不要检索比需求还要多的数据 select \*，返回不必要的数据，增加查询和网络的开销

- ==分页查询==：利用子查询进行优化，虽然会扫描更多的行，但返回的数据会比较少；

  ``` sql
  select * from order where id > (select id from order order by order_no limit 1000, 1) limit 20;
  ```

- 优化==select count(* )== ：mysql 的innodb引擎会扫描表的所有行数得到比较耗时。可以用==近似值和增加统计表==的方式来

  解决。（**所以结论是：按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count(\*)，建议尽量使用 count(\*)或count(1)。**）

### ==重构查询方式==

- 衡量是一个==复杂的查询==还是多个==简单的查询==

  mysql设计上==连接和断开是比较轻量级的==，在返回一个小的查询结果是很高效的。mysql通用服务器上能够支持==每秒10w==的查询，一个千兆网卡很轻松支持每秒2000次的查询，所以运行多个小查询已经不是什么大问题。myql内部每秒能够扫描内存中上百万的数据，但mysql响应客户端会慢很多。

- ==切分查询==
  
  - 对==大查询==需要“==分而治之==”，把一个大查询切分成一个个小的查询，快速高效的返回小的查询结果
  - ==特别是删除时==。删除一个比较大的记录，会锁住比较大的数据，占满事务日志，
  
- ==分解关联查询==
  
  - 让==缓存==更高效（mysql缓存）
  - 查询分解后，执行单个查询可以==减少锁竞争==
  - 可以==减少冗余记录==的查询，在数据库查询时有可能重复的访问一部分数据，这样也有助于降低网络和内存的消耗。

## 如何对大表进行优化？

1. ==**限定数据的范围**==：务必禁止不带任何范围的数据查询语句。比如查询历史订单，可以控制在一个月的范围内。
2. ==**读写分离**==：经典的数据拆分方案，主库负责写，从库负责读。问题：主从延迟问题
3. ==**垂直分区**==：根据数据库里的数据表相关性进行拆分。简单来说数据库的垂直拆分就是数据列的拆分 。例如用户表里有用户基本信息和用户登录信息可以进行垂直拆分 。
   1. 优点：可以使得数据列变小，查询时减小读取的block数，减少io的次数。此外，垂直分区还可以简化表结构，易于维护。
   2. 缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作。可以通过在应用层join来解决。此外，垂直分区会让事务变得更加复杂。
4. ==**水平分区**==：保持数据库的表结构不变，通过某种策略将存储数据分片。这样每一片数据分散到不同的表或库 中，达到分布式的目的。
   1. 优点：水平拆分可以支持非常大的数据量。水平拆分表还在同一台机器上，对于提高并发性能没有什么意义，所以水平拆分最好分库。
   2. 缺点：水平拆分支持非常 大的数据存储，应用端改造也比较少，但分片事务难以解决，跨节点的join性能较差，逻辑复杂。（尽量不要对数据进行分片，拆分会带来逻辑、部署、运维的各种复杂度，一般数据库优化得当支持千万不是问题。如果实在要分片，可以选择客户端分片，可以减少一次和中间件交互的io）

==客户端分片==常用方案：

**客户端代理**： 分⽚逻辑在应⽤端，封装在**jar**包中，通过修改或者封装**JDBC**层来实现。 当当⽹的 **Sharding-JDBC** 、阿⾥的TDDL是两种⽐较常⽤的实现。
**中间件代理**： 在应⽤和数据中间加了⼀个代理层。分⽚逻辑统⼀维护在中间件服务中。 我们现在谈的 **Mycat** 、360的Atlas、⽹易的DDB等等都是这种架构的实现。

# 四、mysql数据库的主从同步如何实现？

![image-20220407192708202](/Users/haibingzhang/d/weiyundata/typoradoc/images/image-20220407192708202.png)

Mysql主从同步过程如下：

- 第一步==主库把数据更改记录到二进制日志中==（Binary Log）。在每次准备提交事务完成数据更新前，

  主库将数据更新的事件记录到二进制日志中。mysql会按事务的提交顺序记录日志。

- 其次==备库启动I/O线程读取主库的二进制日志==，并复制到备库的中继日志中。

- 最后备库通过==SQL线程读取中继日志中的事件==，并重放到备库的数据中。

复制原理：//todo

- 基于语句的复制：mysql5.1之前，好处是实现简单。缺点：1.执行语句时会有依赖，增大了失败的可能 2. 更新必须是串行，这需要更多的锁。
- 基于行的复制：mysql5.1以后，可以正确的复制每一行，一些语句可以被更加有效的复制。复杂语句可能只产生两三条记录，复制行更加有效。

# 五、如何不停机情况下安全的切换数据库

> 场景：单切换分库分表、数据库上云、mysql切换成分析型数据库hbase
> 原则：保证安全性、不丢数据（依赖同步程序和对比补偿程序）

具体流程和风险点：

- ==上线同步程序==，从旧库中复制数据到新库中，并保持实时同步。（mysql可以用binlog）
- ==上线双写程序并验证==，支持双新写新旧两个库，但这个时候只读写旧库，不读写新库。增加开关，方便切换。让这个订单服务稳定运行二周。期间进行验证新版订单服务的稳定性，还要验证新旧库数据一致。（验证时注意数据的一致性）
- 验证后==开启双写==，并==停止同步程序==。注意逻辑，先写旧库，再写新库，以旧库的数据为准。如果出现问题，可以关闭双写，回滚到只读写旧库的状态。
- ==开启对比和补偿程序==，确保新旧数据库完全一致。切换开启双写时会有数据不一致的情况。
	- 开启双写后，至少要运行几周的时间，并要开启对比程序，以时间窗口对比数据。对失败的情况进行补偿。	
- ==流量切换==，逐步切量到新库上。期间如果出现问题，切回旧库。（以一定的规则）
- ==下线对比和补偿程序，关闭双写==，读写都切换到新库。此步是不可逆的。
- 稳定后，下线旧库和订单服务的双写功能 。



//todo

- 海量数据下，如何根据执行计划调优SQL？
- mysql索引体系如何应对海量数据存储？
- 海量数据下，如何设计性能优良的mysql索引

* innodb 对一行数据的读会枷锁吗？不枷锁，读实际读的是副本
  [https://www.cnblogs.com/JavaAC/p/15450793.html](https://www.cnblogs.com/JavaAC/p/15450793.html)
- 如何迁移数据？特别是有运行中的应用时？
- 如何做数据的备份？
- 如何做数据的异地备份？
- 如何解决数据的一致性问题？
- 大数据架构？
- 全同步复制，主从、从从如何交互同步？半同步复制，未返回ack的库如何提供服务？

18. 一条sql执行过程
[https://xie.infoq.cn/article/99a33b75b9867d3343e5e41f2](https://xie.infoq.cn/article/99a33b75b9867d3343e5e41f2)

## 相关

4. 记一次线上sql死锁的事故：如何避免死锁
5. 什么时候需要分库分表
6. 电商系统表设计优化案例
7. 数据库参数配置优化







# tidb

https://blog.csdn.net/qq_33227218/article/details/109205978



# install mysql

> https://stefan.magnuson.co/posts/2016-01-28-reinstalling-mysql-on-osx-with-homebrew/

Uninstalling

- Check ~/Library/LaunchAgents, if homebrew.mxcl.mysql.plist is present then:
- Unload: launchctl unload -w ~ /Library/LaunchAgents/homebrew.mxcl.mysql.plist
- Remove: rm ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist
- Stop the MySQL server process: sudo mysql.server stop
- brew remove mysql
- brew cleanup (note that this command will clean up after more than just MySQL)
- Remove if present:
  /usr/local/var/mysql

Reinstalling

- Select the version that you want to install (in my case, 5.5.x)
- brew tap homebrew/versions
- brew install mysql55
- Follow the post-install instructions as provided by the brew install output
  Add the appropriate directoy to your PATH, e.g. /usr/local/opt/mysql55/bin

