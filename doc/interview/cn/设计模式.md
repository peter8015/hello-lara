

> 对各种设计模式自己的理解。



# 责任链设计模式

## 概念

责任链设计模式是一种行为型设计模式，它允许你将请求沿着对象链传递，每个对象都有机会处理这个请求直到找到能够处理它的对象为止。这样就避免了请求发送者与接收者之间的直接耦合，并且简化了系统结构，因为添加新的处理对象不需要改变原有代码。

## 类图

详细介绍： 在责任链模式中，包含以下主要元素：
抽象处理器（Handler）：定义一个处理请求的接口，其中通常包含一个方法来处理请求和设置下一个处理器的方法。
具体处理器（Concrete Handlers）：实现了抽象处理器接口的具体类，它们可以处理特定类型的请求。每个具体处理器都可以决定是否处理请求，如果能处理，则执行相应的操作；如果不处理或处理完后需要进一步处理，则将请求转发给其后的下一个处理器。
客户端（Client）：创建并初始化责任链，并向链头发出请求。客户端并不关心请求如何被处理以及由哪个处理器处理。



## 类比

比喻说明： 我们可以把责任链模式比作一个公司内部的审批流程。假设员工报销单据需要经过多个级别的领导审批：
抽象处理器就像是“审批官”角色，规定了具有审批权限的人必须具备“审核单据”和“将单据转交给下一级审批人”的能力。
具体处理器则是各级别的领导，如部门经理、总监、总经理等，他们各自负责不同的审批额度范围。当收到报销单时，部门经理会先检查单据是否在其审批权限内，若金额较小可以直接批准；若超出权限但还在总监的审批范围内，则将其转交给总监审批；如此逐级递进，直至单据被某个层级的审批人最终批准或拒绝。
客户端是提交报销单的员工，他只需要将报销单提交给第一个审批人（即部门经理），后续的流转工作则完全由责任链中的审批流程自动完成，无需员工关注每一步的具体审批过程。
通过这种模式，公司的审批流程变得灵活可扩展，新增或调整审批级别时只需修改责任链的配置，而无需修改报销单提交的逻辑或各个审批人的职责实现。

## 实现代码 

定义处理请求的接口： 首先，我们需要定义一个处理请求的抽象接口或者抽象类，它声明了一个处理请求的方法。

``` java
 // 抽象处理器接口
   public interface Handler {
       /**
        * 处理请求方法
        * @param request 请求对象
        * @return 是否有后续处理器可以处理，true表示还有，false表示已处理完毕
        */
       boolean handleRequest(Request request);
   }
```



2. 创建具体处理节点： 实现上述接口，创建一系列具体处理节点。每个节点都可以处理特定类型的请求，并决定是否将请求传递给链中的下一个处理器。

``` java

// 具体处理器A
   public class ConcreteHandlerA implements Handler {
       private Handler nextHandler;

       public void setNext(Handler handler) {
           this.nextHandler = handler;
       }

       @Override
       public boolean handleRequest(Request request) {
           if (request.meetsConditionForA()) {
               // 处理请求
               System.out.println("ConcreteHandlerA handles the request.");
               return false;  // 表示已处理完，无需传递给下一个处理器
           } else if (nextHandler != null) {
               // 将请求传递给下一个处理器
               return nextHandler.handleRequest(request);
           } else {
               return false;
           }
       }
   }
```

3. 构建责任链并发起请求： 客户端按照需求构造责任链，并向链头发送请求，请求沿着链进行传递直至被处理或传完整个链。

``` java
 public class Client {
       public static void main(String[] args) {
           Request request = new Request();  // 创建请求对象

           Handler handlerA = new ConcreteHandlerA();
           Handler handlerB = new ConcreteHandlerB();
           Handler handlerC = new ConcreteHandlerC();

           handlerA.setNext(handlerB);
           handlerB.setNext(handlerC);

           handlerA.handleRequest(request);  // 发起请求
       }
   }
```



## 应用场景

- 日志记录：不同的日志级别（如DEBUG、INFO、WARN、ERROR）可以通过责任链模式实现逐级过滤和处理。
- 权限验证：在系统中，用户访问资源前可能需要通过多个权限检查，每个检查就是一个处理节点。
- 数据预处理：例如在Web应用中，对HTTP请求参数进行合法性校验，每个校验规则作为一个处理器。
- 异常处理：当系统抛出异常时，可以根据异常类型的不同由不同处理器来处理。

## 开源框架中的应用：

责任链设计模式在开源框架中被广泛应用，以下是一些实例：
- Spring Web MVC 中的拦截器（Interceptor）： Spring MVC中的HandlerInterceptor接口和HandlerExecutionChain机制实现了责任链模式。每个拦截器都可以对HTTP请求进行预处理、后处理或者决定是否将请求传递给下一个拦截器或控制器。
- Java Servlet API 中的 Filter： Java Servlet规范中的Filter接口以及FilterChain对象构建了责任链模型。开发者可以定义多个Filter来实现权限验证、日志记录、压缩响应内容等功能，并通过web.xml或注解配置其顺序，使得请求在到达目标Servlet之前会依次经过这些过滤器。
- Apache Commons Chain： Apache Commons Chain是一个轻量级的责任链框架，允许用户创建一组命令（Command），并将它们按特定顺序链接起来处理请求。
- Netty网络框架中的ChannelPipeline： 在Netty中，ChannelPipeline用于处理入站和出站事件，它就是一个典型的责任链模式实现。每个ChannelHandler可以看作是链上的一个节点，根据事件类型执行相应的处理逻辑，并可以选择将事件传递到链上的下一个处理器。
- Spring Validation 和 Hibernate Validator： 在数据校验领域，Spring的Validator接口及其基于JSR-303/JSR-349标准的Hibernate Validator实现，可以通过自定义约束注解和组合使用Validator实现类来构成一个灵活的校验责任链。
日志处理库如Log4j、SLF4J等： 日志处理框架中通常包含多个过滤器或者筛选器，这些组件按照一定的顺序排列，形成了一个处理日志信息的责任链。每条日志消息都会依次经过这个链，满足条件的日志会被相应组件处理并输出。
- 通过上述应用可以看出，责任链模式能够很好地解决模块化处理流程的问题，提高代码的可扩展性和灵活性。

