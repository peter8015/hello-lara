


[toc]

# todo

1. 高频题： https://codetop.cc/home   https://github.com/peter8015/LeetcodeTop
1. 阿里学习https://tianchi.aliyun.com/specials/promotion/2-9?spm=5176.27080692.J_3941670930.22.31fe5699GJxSZy
1. 10个结构+10个算法
    - （数组和字符串、链表）、（栈+队列、散列表）、（二叉树+Trie树+B+、图）、堆、跳表
    - 分治算法、哈希算法、递归+贪心+回溯算法+动态规划、查找算法+搜索、排序、字符串匹配算法
    - 一致性哈希、topN、限流算法
2. 基于数据结构和基础算法，考虑对应算法题目的解决方案，中间件或实际场景解决方案（memcache/）
3. AI相关
4. 如何应对算法面试
- 提问：向面试官提问，消除疑义（哪种列表？数组里放的是什么？是整数吗？数字从何来身份证还是？总共有多少？）

- 设计算法：设计一种算法（时间空间复杂度？大量？其他问题和限制，如何最优？有没有指定特定数据？先用暴力求解再优化）

- 编写伪码：先写伪代码，但务必要告诉面试官会写“真实”代码（理清思路）

- 编写代码：写代码要不紧不慢（多用数据结构、适当设计和重构）

- 测试：测试写好的代码，仔细修正每一处错误（极端用例、错误用例、一般用例、如果复杂可以分治）
  5.算法的五种解法

- 举例法（时钟）

- 模式匹配（匹配算法方案）

- 简化推广

- 简单构造 

- 数据结构头脑风暴（链表、数组、二叉树、堆？）

  

# how to

- 算法要求 

  - 写出可运行代码及测试
  - 写出解题思路和时间复杂度分析
  - 视频讲解解题过程
  
- 极客时间切题四件套

  1. Clarification：澄清题目疑问点，例如边界问题、数据的正负、数据量、数据范围等

  2. Possible solution：可能的解法，暴力、最优解
     - bruth foce , recursion
     
     - dp
     
  3. Coding

  4. Test

- 精通一个领域：高效学习的一种

  1. chunk it up（切碎知识点）: 庖丁解牛：一个大的知识体系分成为小块
  2. deliberate practicing（刻意练习）
  3. Feedback（反馈）每天一个，基础算法 《数据结构与算法经典问题解析》
     极客时间：关注算法思想，算法分类，问题分类   基础搞定视频中的算法  qinchao，wangzheng https://time.geekbang.org/column/article/80459扩展算法分类  https://zhuanlan.zhihu.com/p/349940945leetcode剑指offer  https://leetcode-cn.com/problem-list/e8X3pBZi/不错的文章 https://labuladong.gitee.io/algo/1/4/

  

> 图解数据结构与算法-汪建   图解算法（使用python） --吴灿铭
> https://www.toutiao.com/article/7080403901530341927/?log_from=68b48aebaced_1648704242978
>
> 图解数据结构与算法
>
> 如何学习：刻意练习（高水平的勤奋，不是低水平的重复） 
> 《数据结构与算法经典问题解析》极客时间：关注算法思想，算法分类，问题分类   基础搞定视频中的算法  qinchao，wangzheng   https://time.geekbang.org/column/article/80459
>
> 剑指offer  https://leetcode-cn.com/problem-list/e8X3pBZi/
> 
> 不错的文章 https://labuladong.gitee.io/algo/1/4/
> 
>画解剑指 Offer     https://leetcode-cn.com/leetbook/detail/illustrate-lcof/
> 
>全栈潇晨
> https://www.bilibili.com/video/BV1fY411x7pg?spm_id_from=333.337.search-card.all.click
>
> 面试题参考：
>
> https://mp.weixin.qq.com/s/FgBCop2zFfcX5ZszE0NoCQ
>
> https://github.com/AobingJava/JavaFamily
> 
>华为算法 https://www.nowcoder.com/discuss/828230

![](https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0teus3x9bj20gu0syad5.jpg)
> 面试金典中技术面试如何应对？还有算法题的五种解决法？参见mianshijindian
``` mermaid
```



# 基础数据结构

## 数组

## 链表

### 单向链表

### 双向链表

## 栈

### 基于数组的栈

### 基于链表的栈



## 队列

### 基于数组的队列

### 基于链表的队列



# 递归与动态规划

## 递归

### 阶乘

### 斐波那契数列

## 动态规划

动态规划是解决多阶段决策问题常用的最优化理论。原理就是把多阶段的决策过程转化为一系列的单阶段决策问题，利用各阶段间的递推关系，逐个确定每个阶段的最优化策略，最终堆叠出多阶段决策的最优化决策结果。

### 斐波那契数列

### 最长公共子序列

# 树

``` mermaid
graph LR
A(二叉树)-->B(完全二叉树)
A-->C(满二叉树 )
A-->D(平衡二叉树)
A-->H(B树)

D-->E(二叉搜索树)
D-->F(AVL树)
D-->G(红黑树)
```

## 完全二叉树

一个高度为h的二叉树，除了第h层外，其他各层的节点数都达到了最大个数，则称该树为完全二叉树。

各层节点：2^(n-1)，n为层数

总共节点：2^n - 1

## 满二叉树

除了最后一层叶子节点均无子节点外，其他各层节点都有两个子节点的二叉树。

## 平衡二叉树

左右两个子树的节点高度差的绝对值不超过1，并且左右两棵子树都是平衡二叉树。平衡二叉树常用 的实现方法是AVL树和红黑树。

### 二叉搜索树

二叉搜索树（binary Search Tree, BST）又称为二叉排序树,它通过二叉树将数据组织起来。树的每个节点都包含了键、数据、左子节点指针、右子节点指针和父节点指针。二叉搜索树能够保证键的有序排列，所以查找时使用的是二分查询，效率高。

- 二叉搜索树的左子树的所有键都小于它的根节点的键
- 二叉搜索树的右子树的所有键都大于它的根节点的键

### AVL树

### 红黑树

红黑树（red-black tree）是一种平衡的二叉搜索树，与AVL树类似，都是在执行插入和删除时通过旋转来保持二叉搜索树的平衡。

- 红黑树的查找、插入、删除平均复杂度为O(logn)。
- 根节点是黑色的，叶子节点都为黑色，其他节点不是红色就是黑色。
- 每个红色节点的两个子节点为黑色，不能有两个连续的红色节点。

## B树  //todo 树的插入操作需要梳理 

B树即平衡查找树，一般理解平衡的多路查的树，也称为B-树。B树可以看成是二叉搜索树的一种泛化，即从二叉树变为多叉树，能提供O(logn)的平均时间复杂度。B树一般用在存储系统中，比如数据库或文件系统。

# 非比较排序  //todo 需要梳理 

# 比较排序





## 快速排序

## 堆排序

​       核心思想是将待排序序列分为未排序和已排序两部分，然后每次从未排序中最大或最小元素放入到已排序序列中，反复进行此操作直到把未排序序列中所有元素都加入到已排序序列中。

时间复杂度为：O(nlogn) 其中n为待排序元素的数量。

``` mermaid
graph LR
A[A核心思想]---->B(B待排序序列)
B-->E(E未排序序列)
B-->F(F已排序序列)
E-->G(G最大或最小元素)
G-->F
```



``` java

/**
 * leetcode-cn  703 判断输入数据流中的第K大元素
 * 判断数据流中第k大元素
 * input: {13, 25, 33, 66, 7};  k=3  add key 8
 * output:  13
 *
 * 思路： 使用堆排序思想，找出第k大元素，用优先级队列实现。
 * 时间复杂度为O(nlogn)  空间复杂度
 * 构建堆的平均时间复杂度为O(n)
 */
public class KthLargest {
    // todo priorityqueue
    private int k;
    private PriorityQueue<Integer> queue;

    // todo: construct init
    public KthLargest(int k, int[] nums) {
        this.k = k;
        this.queue = new PriorityQueue(k);

        for(int num : nums) {
            add(num);
        }
    }

    // todo add:compare
    public int add(int key) {
        if(queue.size() > k) {
            queue.poll();
        }
        queue.offer(key);

        return queue.peek();
    }
    // todo exception logic

    // todo test
    public static void main(String[] args) {
        int[] nums = new int[]{13, 25, 33, 66, 7};
        final int k = 3, key = 8, key1 = 10;

        KthLargest kthLargest = new KthLargest(k, nums);
        int r = kthLargest.add(key); //13
        int r1 = kthLargest.add(key1); //10

        System.out.println(r);
        System.out.println(r1);
    }
}
```

# 极客时间

## 05 理论讲解：数组与链表

### 06 面试题：==反转一个单链表&判断一个链表是否有环==

``` java
/**
 * 反转链表 反转单链表
 * 题目：给定一个链表进行反转输出
 * input: [1,2,3,4]
 * output: [4,3,2,1]
 */
public class ReverseList {

    @Test
    public void t1() {
        ListNode n1 = new ListNode(1);
        ListNode n2 = new ListNode(2);
        ListNode n3 = new ListNode(3);
        ListNode n4 = new ListNode(4);

        n1.next = n2;
        n2.next = n3;
        n3.next = n4;

        reverseList(n1);

        // 1. null & negative & largest &smallest
        assertNull(null);
        // use case
        assertEquals(3, n4.next.val);
        assertEquals(2, n4.next.next.val);
    }

    /**
     * 解法一：递归实现
     * <p>
     * 时间复杂度：O(n)，其中n为链表长度，需要对链表的每个节点进行反转操作。
     * 空间复杂度：O(n)，其中n为链表长度。递归主要取决于调用栈空间，最多为n层。
     */
    public ListNode reverseList(ListNode head) {
        //add bound and exception logic and final condition
        if (head == null || head.next == null) {
            return head;
        }

        ListNode p = reverseList(head.next);
        head.next.next = head;
        head.next = null;

        return p;
    }

    /**
     * 解法二：迭代实现。在遍历链表时，需要将当前节点的指针指向前一个节点，因此事先必须保存前一个节点。
     * 在更改引用之前，还需要存储后一个节点。
     * 时间复杂度：O(n)，其中n为链表长度，只需要遍历一次链表即可。
     * 空间复杂度：O(1)
     *
     * 1. big data?
     * 2. special scene data?
     * 3. other risk?
     * 4. test case?
     */
    public ListNode reverseListx(ListNode head) {
        // add bound and exception logic
        if(head == null || head.next == null) return head;

        // store prev and curr pointer
        ListNode prev = null;
        ListNode curr = head;

        // perform list reverse operation
        while(curr != null) {
            ListNode temp = curr.next;

            curr.next = prev;
            prev = curr;
            curr = temp;
        }
        return prev;
    }
}

```

``` java
/**反转链表II 区间内链表反转
 * <p>
 * 题目：给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置
 * left 到位置 right 的链表节点，返回 反转后的链表 。
 * input: [1,2,3,4,5]  2, 4
 * output: [1,4,3,2,5]
 * /
/**
     * 解法一
     * 思路：根据left 和 right截取出子链表，并进行反转再对接到原链表中
     * [1,2,3,4,5] -> [1,4,3,2,5]
     * 时间复杂度：O(N)，其中N为链表总节点数。最坏情况下，需要遍历整个链表
     * 空间复杂度：O(1)，只使用了常数个变量。
     * 关键是画出截取后子链表的节点与新的链表的对应
     * prev->leftNode      rightNode -> curr
     */
    public ListNode reverseBetweenx(ListNode head, int left, int right) throws Exception {
        // add bound or exception logic
        if (head == null || head.next == null) return head;

        // add left and right pointer, and determine the position of the left and right pointer
        ListNode dummyNode = new ListNode(-1);
        dummyNode.next = head;

        ListNode pre = dummyNode;
        for (int i = 0; i < left - 1; i++) {
            pre = pre.next;
        }

        ListNode rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) {
            rightNode = rightNode.next;
        }

        // add leftNode and curr pointer to store node, and cut List to get child
        ListNode leftNode = pre.next;
        ListNode cur = rightNode.next;
        pre.next = null;
        rightNode.next = null;

        // reverse child list
        reverseLinkedList(leftNode);

        // get final result with docking list
        pre.next = rightNode;
        leftNode.next = cur;

        return dummyNode.next;
    }

    /**
     * Reverse listNode with recursive
     * O(n) O(n)
     *
     * @param head
     * @return ListNode
     */
    public ListNode reverseList(ListNode head) {
        // add bound or exception logic
        if (head == null || head.next == null) {
            return head;
        }
        // add recursive logic
        ListNode p = reverseList(head.next);
        head.next.next = head;
        head.next = null;

        return p;
    }
```


## 07 理论讲解：堆栈和队列

### 08 面试题：==判断括号字符串是否有效==

### 09 面试题：==用队列实现栈&用栈实现队列==

## 10 理论讲解：优先队列

11 面试题：==返回数据流中第K大元素==
12 面试题：==返回滑动窗口中最大的值==

## 13 理论讲解：哈希表

14 面试题：有效的字母异位词
面试题：==两数之和==
面试题：==三数之和==

## 理论讲解：树&二叉树&二叉搜索数

面试题：验证二叉搜索树

放弃

面试题：二叉树&二叉搜索树的最近公共祖先

235，236



理论讲解：二叉树的遍历 



## 理论讲解：递归&分治

面试题：Pow(x,n)
面试题：求众数
理论讲解：贪心算法
面试题：买卖股票的最佳时机

## 理论讲解：==广度优先搜索&====深度优先搜索==
面试题：二叉树的层次遍历 
面试题：二叉树的最大和最小深度
面试题：==生成有效括号组合==

## 理论讲解：剪枝

面试题：N皇后问题
面试题：数独问题

## 理论讲解：二分查找

面试题：实现一个求解平方根的函数

## 理论讲解：字典数（tried[‘trai]树）

Trie树(retrieve)树（读try树）：即字典树，又称为前缀树或单词树。是一种树形数据结构，哈希树的变种，用于高效的存储和检索字符串数据集中的健。典型应用是用于统计和排序大量的字符串（不限于字符串）、自动补全、拼写检查。常用于搜索引擎系统中的文本词频的统计。

基本特性：根节点不存储字符，每个节点存储一个字符，到叶子节点走过的路径形成一个单词。

优点：最大限度的减少无用的字符串的比较，查询效率比哈希树还要高。

核心思想：空间换时间，以字符串的公共前缀来降低查询的时间，提高查询的效率。

![image-20220513111623512](https://lz.sinaimg.cn/large/e6c9d24ely1h26lwibkv9j20ys0sy768.jpg)

``` java
final static ALPHBET_SIZE = 256; //小写、大写、特殊字段   
static class TriNode {
	  TrieNode[] children = new TrieNode[ALPHBET_SIZE];
    boolean isEndOfWord = false;
    
    TrieNode() {
      isEndOfWord = false;
      for(int i = 0; i < ALPHBET_SIZE; i++) {
        children[i] = null;
      }
    }
}
```

``` python
class TrieNode:
  def _init_(self):
    self.children = [None] * ALPHBET_SIZE
    self.isEndOfWord = False
```



面试题：实现一个字典数

``` java
package com.future.algorithm;

import org.junit.Test;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

/**
 * Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
 *
 * 请你实现 Trie 类：
 *
 * Trie() 初始化前缀树对象。
 * void insert(String word) 向前缀树中插入字符串 word 。
 * boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
 * boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
 *
 * 链接：https://leetcode.cn/problems/implement-trie-prefix-tree
 */
public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode current = root;
        int len = word.length();

        for (int i = 0; i < len; i++) {
            int index = word.charAt(i) - 'a';
            if (current.children[index] == null) {
                current.children[index] = new TrieNode();
                current.children[index].isWord = false;
            }
            current = current.children[index];
        }
        current.isWord = true;
    }

    public boolean search(String word) {
        TrieNode node = find(word);

        return node != null && node.isWord;
    }

    public boolean startWith(String prefix) {
        return find(prefix) != null;
    }

    public TrieNode find(String word) {
        TrieNode current = root;
        for (int i = 0; i < word.length(); i++) {
            int index = word.charAt(i) - 'a';
            if ((current = current.children[index]) == null) {
                return null;
            }
        }
        return current;
    }

    @Test
    public void t1() {
        Trie trie = new Trie();

        trie.insert("abcdef");
        trie.insert("abcfde");
        trie.insert("abcehi");
        trie.insert("abcehabc");

        assertTrue(trie.search("abcdef"));
        assertTrue(trie.search("abcehabc"));
        assertFalse(trie.search("abcehabcddd"));

        assertFalse(trie.startWith("aaaa"));
        assertTrue(trie.startWith("abc"));
    }
}


class TrieNode {
    TrieNode[] children;
    boolean isWord;

    public TrieNode() {
        children = new TrieNode[256];
        isWord = true;
    }
}
```



面试题：二维风格中的单词搜索问题

## 理论讲解：位运算

面试题：统计位1的个数
面试题：2的幂次方问题&比特位计数问题
面试题：N皇后问题的另一种解法

## 理论讲解：动态规划

面试题：==爬楼梯===
面试题：==三角形的最小路径和===
面试题：乘积最大子序列
面试题：股票买卖系列
面试题：零钱兑换
面试题：编辑距离

## 理论讲解：并查集

面试题：岛屿的个数&朋友圈上
面试题：岛屿的个数&朋友圈下

## 理论讲解：==LRU Cache==

面试题：设计和实现一个LRU Cache缓存机制
理论讲解：布隆过滤器



## 数据结构

<img src="https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tg8tw8iej20u00xuwhd.jpg" alt="image-20220331222316507" style="zoom:50%;" />



<img src="https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tg8r8a85j20v70u0ace.jpg" alt="image-20220331222335958" style="zoom: 50%;" />



![image-20220331222507089](https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tfkzs5oqj214u0u0q88.jpg)







# 经典算法

## 分治法

## 递归法

## 贪心法

## 动态规划法

## 迭代法

## 枚举法

## 回溯法

 

# 查找算法

## 顺序查找

## 二分查找

## 插值查的

## 斐波那契查找法

# 信息安全基础算法

## 数据加密



# 堆栈与队列相关的算法

## 汉诺塔问题

## 八皇后问题

## 双向队列

## 优先队列

## 用数组、链表实现堆栈

## 用数组、链表实现队列

# 树相关的算法

## 用数组、链表实现二叉树

## 二叉树的遍历、查找、节点的插入、删除



# 图相关的算法

# 人工智能基础算法

## 机器学习简介

### 监督式学习
### 半监督式学习
### 无监督学习与k均值聚类
### 强化学习
## 认识深度学习
### 人工神经网络
### 卷积神经网络
### 循环神经网络





# 算法设计题

## 一致性哈希算法

> *1997年由麻省理工学院的Karger等人提出。起初是为了解决internet中热点问题，现在被广泛用来解决分布式cache的问题。*[*https://www.cnblogs.com/lpfuture/p/5796398.html*](https://www.cnblogs.com/lpfuture/p/5796398.html)

- **算法思想：以memcache为例**

  <img src="https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tfy1bivsj21r80t8wip.jpg" alt="image-20220331223738005" style="zoom:50%;" />

- **初始化**：首先求出memcache的服务节点的哈希值，并将其配置在一个0~2^32的圆上。 

- **映   射**：然后用同样的算法求出要存储的数据的健的哈希值，并映射到相同的圆上。 

- **存   储**：从数据映射到圆的位置开始顺时针查找，将数据保存到找到的第一台服务器上。如果超过2^32仍找不到节点，那就保存到第一个节点上。

- **新   增**：有新的服务器加入，如果是余数的分布式算法，会导致服务器发生巨大的变化而影响命中率。一致性哈希中，只有在新节点到其在圆上逆时针的第一个节点之间的数据会受到影响。

  例如：新增节点为node5（图2），他的逆时针第一个节点为node2，他们之间存储的健为key1,key2,key3,那只有这三个健的位置会受影响。    

<img src="https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tg05r1suj214a0u0acs.jpg" alt="image-20220331223936358" style="zoom: 33%;" />

<img src="https://i0.wp.com/i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tg0lol75j211e0u0q5t.jpg" alt="image-20220331224003971" style="zoom:33%;" />



- **利用guava实现一致性哈希算法**

  guava中有一个hashing类实现了一致性哈希算法。有一个consistentHash静态方法，可以直接调用。

  ``` java
  //bucket 范围在0~buckets之间 
  int bucket = Hashing.consistentHash(id, buckets);
  // 传入数据主键的分片片健和集群中机器的数量buckets，返回bucket即为机器位置。
  ```

  

``` java
//Assign to input a "bucket" in the range [0, buckets]
public static int consistentHash(long input, int buckets) {
  //检查buckets参数，不能为负数
  checkArgument(buckets > 0, "buckets must be positive: %s", buckets);
  //利用内部的LCG算法实现，产生伪随机数
  LinearCongruentialGenerator generator 
                       = new LinearCongruentialGenerator(input);
  int candidate = 0;
  int next = 0;
  
  while(true) {
    //每次hash循环中next的值是固定的
    next = ((candidate + 1) / generator.nextDouble());
    if(next >= 0 && next < buckets) {
      //如何值在[0，buckets]范围外，就会把next值赋给candidate，重新进行计算
      cadidate = next;
    } else {
      //如果值在[0, buckets]范围内，就返回candidate值，作为input的存储 位置 
      return candidate;
    } 
  }
}

//LCG算法
private static final class LinearCongruentialGenerator {
  private long state;
  
  public LinerCongruentialGenerator(long seed) {}
  
  public double nextDouble() {
    state = 2862933555777941757L * state + 1;
    return ((double)((int)(state >>> 33) + 1)) / (0x1.0p31);
  }
}

```





## 海量数据的处理

> java程序员面试笔试

基本方法

- hash法

- bit-map法

- BloomFilter法

- 数据库优化法

- 倒排索引法

- trie 树

- 堆

求海量数据中前n大/小的值中位数：最大堆-求前n小，最小堆-求前n大，双堆-中位数

- 双层桶法

一种算法思想，类似于分治算法。平均时间复杂度O(n)

- MapReduce法

### topN问题 //=todo 20220511

在搜索引擎中，统计搜索最热门的10个查询词。在歌曲库中下载量排前10的歌曲等

对于topN问题，通常比较好的解决方案是分治法+trie树/hash+小顶堆。

### 重复问题

- 暴力求解O(n^2)
- 哈希查找O(n) O(n)
- 数组代替哈希（同上，性能不如上）
- 最优解法O(n) O(1)

### 排序问题



## 限流算法

> 参考https://www.toutiao.com/a6967956383346180616/?channel=&source=search_tabhttps://zhuanlan.zhihu.com/p/60979444https://zhuanlan.zhihu.com/p/79674899https://zhuanlan.zhihu.com/p/335764667常用的限流方式和场景有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limitconn模块，用来限制瞬时并发连接数，Java的Semaphore也可以实现）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limitreq模块，限制每秒的平均速率）（多线程任务执行速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。比如说，我们需要限制方法被调用的并发数不能超过100（同一时间并发数），则我们可以用信号量 Semaphore实现。可如果我们要限制方法在一段时间内平均被调用次数不超过100，则需要使用 RateLimiter。

- 限流有四种算法：

  - 固定时间窗口算法： RedisAtomicInteger   简单计数法，优点在固定的时间出现流量溢出会立即限流。缺点是会出现两倍的情况。

  - 滑动时间窗口算法：计数思想，优点是解决了两倍的问题（https://blog.piaoruiqing.com/2019/08/26/openapi-gateway-restriction/） 

  - 令牌桶算法

    概念：Guava 采用的是令牌桶算法，其核心是定时向令牌桶发送令牌，请求能够从令牌桶中拿到令牌，然后才能通过限流器。也就是说，只要我们能够限制发放令牌的速率，那么就能控制流速了。 

    详细描述：令牌以固定的速率添加到令牌桶中，假设限流的速率是 r个请求/ 秒，则令牌每 1/r 秒会添加一个；请求能够通过限流器的前提是令牌桶中有令牌。假设令牌桶的容量是 b ，如果令牌桶已满，则新的令牌会被丢弃。我们只需要记录一个下一令牌产生的时间，并动态更新它，就能够轻松完成限流功能。

  <img src="https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tg55up9yj218b0u0ad7.jpg" alt="image-20220331224422876" style="zoom: 33%;" />

  - **漏桶算法**（Leaky Bucket）。(了解)

    **描述**：像一个漏斗一样，进来的水量就好像访问流量一样，而出去的水量就像是我们的系统处理请求一样。当访问流量过大时，这个漏斗中就会积水，如果水太多 了就会溢出。     

    <img src="https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tg7wmaimj21150u0tac.jpg" alt="image-20220331224601543" style="zoom: 33%;" />   

    

    

    **实现**：漏桶算法的实现往往依赖于队列，请求到达如果队列未满则直接放入队列，然后有一个处理器按照固定频率从队列头取出请求进行处理。如果请求量大，则会导致队列满，那么新来的请求就会被抛弃。        

    <img src="https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tg7kgwf2j21c60go401.jpg" alt="image-20220331224637440" style="zoom:50%;" />

  

  - Guava RateLimiter（单机限流）

    **RateLimiter应用代码：**提供了**平滑突发限流**(SmoothBursty)和**平滑预热限流**(SmoothWarmingUp)实现。

``` java
//创建限流器，限速2个请求/秒
 RateLimiter limiter = Ratelimiter.create(2.0);
 ExecutorService es = Executors.newFixedThreadPool(1);
 ​
 for(int i = 0; i < 20; i++) {
   //限流器进行限流
   limiter.aquire();
   es.execute(() -> {});
 } ​
```



- 分布式限流(待补充)

  想要在集群中进行全局限流, 其关键在于将限流信息记录在共享介质中, 如`Redis`、`memcached`等. 为了将限流做的精确, 写必须是原子操作. 

<img src="https://i0.wp.com/lz.sinaimg.cn/large/e6c9d24ely1h0tgbmocytj21cc0u041h.jpg" alt="image-20220331225043142" style="zoom: 33%;" />

`Redis`+`Lua`是一个不错的选择, 示例`Lua`脚本如下:

``` java
local key = KEYS[1] -- 限流的KEY
local limit = tonumber(ARGV[1]) -- 限流大小
local current = tonumber(redis.call('get', key) or '0')
if current + 1 > limit then
    return 0
else
    redis.call('INCRBY', key,'1')
    redis.call('expire', key,ARGV[2])   -- 过期时间
    return current + 1
end

```

 分布式限流将令牌的发放放到共享介质中.获取(消费)令牌操作必须是原子的.共享介质要高可用(Redis集群)



## google大数据量的topN算法

> Count-min sketch   

https://www.geeksforgeeks.org/count-min-sketch-in-java-with-examples/

``` java
        CountMinSketch countMinSketch = new CountMinSketch(0.001, 0.09, 1);

        countMinSketch.add("75.245.10.1", 1);
        countMinSketch.add("10.125.22.20", 1);
        countMinSketch.add("192.170.0.1", 2);

        System.out.println(countMinSketch.estimateCount("192.170.0.1"));
        System.out.println(
                countMinSketch
                        .estimateCount(
                                "192.170.0.1"));
        System.out.println(
                countMinSketch
                        .estimateCount(
                                "999.999.99.99"));
```



# 面试金典

如何应对技术面试：

- 提问：向面试官提问，消除疑义。

  比如 数据类型是什么？数字、字符、链表？是整数吗？数字来身何处？身份证号？ 总共有多少？一般会提问数据类型、数据出处、数据量。

- 设计算法：建议先暴力求解

  - 算法的空间和时间复杂度？
  - 碰到大数据量怎么办？
  - 设计是否会引发其他的问题？
  - 如果面试官指定 了特定的数据该如何处理？

- 编写伪代码

  伪代码有助于理清思路，务必沟通会写真实的代码。

- 编写代码

  - 多用数据结构，写代码不要太杂乱。

- 编写测试

  - 极端用例：0，-1，null，最大和最小值 
  - 用户错误的输入：用户传入值为空或负数等
  - 一般正常用例

算法题的五种解法：

- 举例法：时钟指针
- 模式匹配法：与已有的题目和算法做匹配
  - 如在一个无序的数组中找出最小值 ：
  - 有一个有序的数组 中找出特定的值：二分查找

- 数据结构头脑风暴
  - 数组和链表、栈和队列、二叉树、
  - 堆非常适合排序，跟踪最大值和最小值 

## 数组与字符串

### 1. 判断一个字符串中的字符都不同

``` java
package com.macro.mall.mianshijindian;

import org.junit.Test;

import static junit.framework.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

/**
 * 判断一个字符串中所有的字符都不相同
 */
public class AllDiff {

    /**
     * test cases
     */
    @Test
    public void t1() {
        String s1 = "abc";
        String s2 = "123";
        String s3 = "a";
        String s4 = null;

        assertTrue(isDiff(s1));
        assertTrue(isDiff(s2));
        assertTrue(isDiff(s3));
        assertFalse(isDiff(s4));
    }

    /**
     * 1. nest loop  O(n^2) O(1)
     * 2. set O(n) O(n)
     * 3. |  ^  &
     * "abc"-> set a, b, c-> add -> false
     *
     * @param s
     * @return
     */
    public boolean isDiff(String s) {
        if(s == null) return false;

        boolean r = true;

        char[] chars = s.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            int c = chars[i];
            for (int k = i + 1; k < chars.length; k++) {
                if (c == chars[k]) {
                    r = false;oii87777
                    break;
                }
            }
        }
        return r;
    }

     /**
     * Defined boolean array store char of string.
     * Set true if char exist.
     * 时间复杂度O(n), n 为字符串长度，空间复杂度为O(1)
     * @param s
     * @return	
     */
    public boolean isDiffB(String s) {
        char[] chars = s.toCharArray();

        //bound logic
        if(s == null) {
            return false;
        }

        //defined boolean arrays
        boolean[] bs = new boolean[256];

        for(int i = 0; i < chars.length; i++) {
            char c = chars[i];
            if(bs[c]) {
                return false;
            }
            bs[c] = true;
        }
        return true;
    }

}

```



### 2. 变位词：给定两个字符串，请编写程序，确定其中一个字符串的字符重新排序后，能否变成另外一个字符串。

``` java
/**
 * 给定两个字符串，确定其中一个字符串的字符重新排序后，能否变成另外一个字符串（变位词）
 *
 * input:[abcd]
 * output:[dcba]
 */
public class isSameAfterReverse {
    //test code
    @Test
    public void t1() {
        String source = "1324";
        String target = "1432";

        assertTrue(isSame(source, target));
    }

    //O(nlogn) O(n)
    public boolean isSame(String source, String target) {
        //bound logic
        if(source == null || target == null) {
            return false;
        }
        if(source.equals(target)) {
            return true;
        }

        // return false if s.len != t.len
        if(source.length() != target.length()) {
            return false;
        }

        //Arrays.sort(String)
        char[] c_s = source.toCharArray();
        char[] c_t = target.toCharArray();
        Arrays.sort(c_s);
        Arrays.sort(c_t);

        //todo compare logic
        String s1 = new String(c_s), s2 = new String(c_t);
        return s1.equals(s2);
    }
}
```







# 算法题目

## 1. leetcode-cn  120. 三角形最小路径和（动态规划）

```java
/**
 * leetcode-cn  120. 三角形最小路径和
 * 给定一个三角形 triangle ，找出自顶向下的最小路径和。
 *
 * 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。
 * 也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
 *
 * 输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
 * 输出：11
 * 解释：如下面简图所示：
 *    2
 *   3 4
 *  6 5 7
 * 4 1 8 3
 * 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
 * 
 * 时间复杂度：O(n^2) n为三角形的行数
 * 空间复杂度：O(n^2) n为三角形的行数
 */
public class TriangleMin {
    @Test
    public void t1() {
        List<List<Integer>> triangles = new ArrayList<>();

        List<Integer> e1 = new ArrayList<>();
        e1.add(2);
        triangles.add(e1);
        List<Integer> e2 = new ArrayList<>();
        e2.add(3);
        e2.add(4);
        triangles.add(e2);
        List<Integer> e3 = new ArrayList<>();
        e3.add(6);
        e3.add(5);
        e3.add(7);
        triangles.add(e3);
        List<Integer> e4 = new ArrayList<>();
        e4.add(4);
        e4.add(1);
        e4.add(8);
        e4.add(3);
        triangles.add(e4);

        System.out.println(minTotal(triangles));
    }

    /**
     * 动态规划. 定义二维 dp 数组，将解法二中「自顶向下的递归」改为「自底向上的递推」。
     * 1. 状态定义：dp[i][j] 表示从点 (i, j)(i,j) 到底边的最小路径和。
     * 2. 状态转移：dp[i][j]=min(dp[i+1][j],dp[i+1][j+1])+triangle[i][j]
     * @param triangles
     * @return
     */
    public int minTotal(List<List<Integer>> triangles) {
        //todo 定义状态
        int n = triangles.size();
        int dp[][] = new int[n + 1][n + 1];

        //todo 定义状态转移方程
        for (int i = n - 1; i >= 0; i--) {
            for (int j = 0; j <= i; j++) {
                dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangles.get(i).get(j);
            }
        }
        return dp[0][0];
    }
}
```





## 2. 判断一个ip是否在一个IP断内（字符串）

```java
/**
 * 题目：判断一个ip地址是否在一个地址段中
 * 例如："192.168.0.111" 是否在地址段 "192.168.0.0~192.168.0.255"
 * 分析：需要转换成long，判断给定的ip是否在地址范围内
 */
public class IpRange {
    public static void main(String[] args) {
        String ip = "192.168.0.111";
        String range = "192.168.0.0~192.168.0.255";
        boolean b = isInRange(ip, range);
        System.out.println(b);
    }
    /**
     * 判断给定IP地址是否在范围内
     *
     * @param ip
     * @param range
     * @return
     */
    public static boolean isInRange(String ip, String range) {
        int pos = range.indexOf("~");
        long x = ipToLong(ip);
        long s = ipToLong(range.substring(0, pos));
        long e = ipToLong(range.substring(pos + 1));
        return x >= s && x <= e;
    }
    /**
     * ip to long
     *
     * @param ip
     * @return
     */
    public static long ipToLong(String ip) {
        String[] ips = ip.split("\\.");
        long r = 0L;
        for (int i = 0; i < ips.length; i++) {
            r = r << 8 | Integer.parseInt(ips[i]);
        }
        return r;
    }
}

```



## 3. 合并两个有序链表（链表）

```java
/**
 * 题目：输入两个递增的链表，合并两个链表并使新链表中的节点仍是递增排序的。
 * 例如：
 * input: 1->2->4, 1->3->4
 * output: 1->1->2->3->4->4
 * 算法分析：
 * 1. 初始化：伪头节点dump，节点cur指定了dump
 * 2. 循环合并：当n1或n2为空时跳出
 * 
 * 3. 合并剩余尾部
 * 复杂度分析：
 * 时间复杂度：O(M+N) m,n分别为n1,n2的长度，合并操作需要遍历两个链表
 * 空间复杂度：O(1)，节点引用了dump，cur使用了常数大小的空间
 */
public class Offer25 {
    @Test
    public void t1() {
        ListNode n1 = new ListNode(1);
        ListNode n2 = new ListNode(2);
        ListNode n3 = new ListNode(4);
        ListNode n4 = new ListNode(1);
        ListNode n5 = new ListNode(3);
        ListNode n6 = new ListNode(4);
        n1.next = n2;
        n2.next = n3;
        n4.next = n5;
        n5.next = n6;
        ListNode r = mergeList(n1, n4);
        assertEquals(1, r.val);
        assertEquals(1, r.next.val);
        assertEquals(2, r.next.next.val);
        assertEquals(3, r.next.next.next.val);
    }
    public ListNode mergeList(ListNode n1, ListNode n2) {
        ListNode dump = new ListNode(0);
        ListNode cur = dump;
        while(n1 != null && n2 != null) {
            if(n1.val < n2.val) {
                cur.next = n1;
                n1 = n1.next;
            } else {
                cur.next = n2;
                n2 = n2.next;
            }
            cur = cur.next;
        }
        cur.next = n1 != null ? n1 : n2;
        return dump.next;
    }
}

```
## 4. 共享单车的监控问题

## 5. 找出数组中重复的数字（数组）

```java
/**
 * 判断数组中重复的数字：在一个长度为n的数组里所有的数字都在0~n-1范围内。数组中某些数字是重复的，
 * 但不知道重复的有几个，重复了几次。请找出数组中任意一个重复的数字。
 * 2 <= n <= 100000
 * 方案一：暴力求解 遍历数组中的每一个元素，在剩余的数字中寻找相同数字
 * 时间复杂度：  O(n^2)  空间复杂度  O(1)
 * 方案二：哈希查找
 * 1. 先创建一个哈希表（hashset）
 * 2. 然后遍历每一个元素，进行如下处理
 * - 如果哈希表不存在则加入哈希表
 * - 如果哈希表中存在则直接返回
 * 空间换时间，时间复杂度为O(n)
 * 空间复杂度为O(n)
 * 方案三：最优解法 O(n)  O(1)
 */
public class Offer03 {
    @Test
    public void t1() {
        int[] nums = new int[]{1,2,3,4,5,2,3};
        System.out.println(findDuplicate(nums));
    }
    public int findDuplicate(int[] nums) {
        Set<Integer> sets = new HashSet();
        for(int i = 0; i < nums.length; i++) {
            int k = nums[i];
            if(sets.contains(k)) {
                return k;
            } else {
                sets.add(k);
            }
        }
        return -1;
    }
}
```
## 6. threesum（数组）

* 三种之和，是twoSum升级版，twoSum用暴力解法的时间复杂度为O(n^2)，那threeSum暴力解法的时间复杂度为O(n^3)，空间复杂度为O(n)。时间复杂度太高，会出现超时。
* 第二种解法为逼近算法，？？
```java
/**
 * leetcode 15
 * 给定一个包含n个数的数组nums， 判断nums是否存在三个元素a，b，c，使得a+b+c=0，请找出三个且不重复数三元组。
 * input: nums = [-1,0,1,-1,2]
 * output: [-1, 0, 1],[-1, -1, 2]
 * 1. 暴力解法 O(n^3): 进行三层循环。
 * 2. set, O(n^2)
 *
 */
@Test
public void test() {
    int[] nums = {-1, 0, 1, 2, -1, -4};
    Set<List<Integer>> ret = threeSum(nums);
    System.out.println(ret);
}

/**
 * 时间复杂度：O(n^3) 空间复杂度：O(1)
 *
 * @param nums
 * @return
 */
public Set<List<Integer>> threeSum(int[] nums) {
    Set<List<Integer>> sets = new HashSet();
    if(nums == null) {
        return sets;
    }
    for(int i = 0; i < nums.length; i++) {
        for(int j = i + 1; j < nums.length; j++) {
            for(int k = j + 1; k < nums.length; k++) {
                if(nums[i] + nums[j] + nums[k] == 0) {
                    List<Integer> data = Arrays.asList(nums[i], nums[j], nums[k]);
                    Collections.sort(data);
                    if(!sets.contains(data)) {
                        sets.add(data);
                    }
                }
            }
        }
    }
    return sets;
}

		//official version  O(N^2)  O(1)
    //三数之和为0， 由L，R分别向中间移动
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList();
        int len = nums.length;
        if (nums == null || len < 3) return ans;
        Arrays.sort(nums);
        for (int i = 0; i < len; i++) {
            if (nums[i] > 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 去重
            int L = i + 1;
            int R = len - 1;
            while (L < R) {
                int sum = nums[i] + nums[L] + nums[R];
                if (sum == 0) {
                    ans.add(Arrays.asList(nums[i], nums[L], nums[R]));
                    while (L < R && nums[L] == nums[L + 1]) L++; // 去重
                    while (L < R && nums[R] == nums[R - 1]) R--; // 去重
                    L++;
                    R--;
                } else if (sum < 0) L++;
                else if (sum > 0) R--;
            }
        }
        return ans;
    }
```

## 6. 如何实现浏览器的前进和后退（栈和队列）

>[https://time.geekbang.org/column/article/41222](https://time.geekbang.org/column/article/41222)
```java
//当你依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，
//就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，
//点击前进按钮，就可以重新查看页面 b 和 c。
//但是，如果你后退到页面 b 后，点击了新的页面 d，
//那就无法再通过前进、后退功能查看页面 c 了。
```
**解决方案**：
用x、y两个栈来实现，将首次浏览的界面压入x栈，后退从x栈中取出，压入y栈。当点击前进按钮时，依次从y栈中取出，放入栈x中。当x没有数据时说明没有界面可后退了，当y没有数据时说明没有界面可前进了。

## 7. 查找总结：给定一个数组和一个值，在数组中查找此值并返回值对应的索引，期望时间复杂度达到log2n。（数组）

>[https://blog.csdn.net/xushiyu1996818/article/details/90604118](https://blog.csdn.net/xushiyu1996818/article/details/90604118)
>
>红黑树   https://blog.csdn.net/xushiyu1996818/article/details/85122375

![image-20220411100950819](https://lz.sinaimg.cn/large/e6c9d24ely1h15k5m81j6j21hs0q0n21.jpg)

## 8. 二分查找O(log2n) （数组、查找）

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```java
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```



```java
//时间复杂度为O(log2n)
public class BinarySearch {
    @Test
    public void t1() {
        int[] nums = {-3, 1, 2, 4, 6};
        binarySearch(nums, 4);
    }
    public int binarySearch(int[] nums, int key) {
        if(null == nums) {
            return -1;
        }
        int left = 0, right = nums.length - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(key == nums[mid]) {
                return mid;
            } else if(key < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }
}

```

## 9. 按位计算与，异或（数组和位运算）

```java
//向左移位相当于*2^n次幂，向右移位相当于除以/2^n  //todo
@Test
public void t2() {
    int[] nums = new int[]{1, 3, 5, 7, 9, 11, 111, 1111, 2, 14};
    for (int num : nums) {
        if (!isOdd(num)) {
            System.out.println(num);
        }
    }
}
public boolean isOdd(int num) {
    return (num & 1) == 1;
}
```



## 10. 动态规划-爬楼梯（动态规划）

> climb stairs  //todo再明确下题目  [1,2] [2,1]是否是重复的？

```java
//O(n) O(n)
class Solution {
    public int climbStairs(int n) {
        if(n == 0 || n == 1 || n == 2) return n;

        int[] mem = new int[n];
        mem[0] = 1;
        mem[1] = 2;

        for(int i = 2; i < n; i++) {
            mem[i] = mem[i - 1] + mem[i - 2];
        }
        return mem[n - 1];
    }
}
```



## LRU（应用）

> Leetcode-cn 146 LRU缓存

==实现思路==：维护一个==有序的单链表==，越靠近==链表尾部==是越早之前访问的。有新的数据被访问时，从链表的头部开始顺序遍历链表。时间复杂度为O(n)

- 如果此数据==已经被缓存==到链表中了，我们顺序遍历链表对应的节点，并将其从原来的位置删除。把新元素==加入到链表头部==。
- 数据==未被缓存==到链表中，存在两种情况：
  - 如果==链表未满==，将此节点直接插入到链表的头部。
  - 如果==链表已满==，则删除==链表尾节点==，将新的节点插入链表头部。
- 优化思路：可以==引入散列表==记录每个数据的位置，将缓存访问的时间复杂度为降到O(1)。

``` flow
start=>start: start

op=>operation: 遍历此数据对应节点并删除(op)
op1=>operation: 插入到链表头部(op1)
op2=>operation: 删除链表尾节点(op2)
op3=>operation: (op3)
cond=>condition: cond-cached?(cond)
cond1=>condition: cond1-full?(cond1)
end=>end: end

start(right)->cond(right)
cond(yes)->op
op->op1
cond(no)->cond1
cond1(yes)->op2->op1
cond1(no)->op3->op1
```



### 方法1：哈希表+双向链表

- 关键字：key value

- 模式识别：一旦出现键和值，就可以想到==哈希表==

- 改变数据的==访问时间==：
	
	- 需要能随机访问
	- 需要把数据插入到头部或尾部
	
	![image-20220405152409459](https://lz.sinaimg.cn/large/e6c9d24ely1h0yviky9akj20um0763yv.jpg)

``` java
LRUCache cache = new LRUCache(2);

cache.put(1, 1);
cache.put(2, 2); //执行到这里的截图
cache.get(1); //因为node1被访问所以会移动到链表尾部
cache.put(3, 3);
```



my algorithm practise 

![image-20220405163703828](https://lz.sinaimg.cn/large/e6c9d24ely1h0yxme150bj20zg0863zn.jpg)

## 找出数组中的重复的数并按出现次数排序（数组和查找）

``` java
class：FindUnique
  /**
 * 给定一个整数数组，找出其中不重复的整数返回；找出其中重复的整数，并根据出现次数倒序返回
 * input: {1,1,1,2,2,3,3,3,3,5,6,7,8,8,8,8,8,8,8}
 * output1: 5,6,7
 * 1-3, 2- 2, 3-3,8-7
 * output2: 8，3， 1，2
 * <p>
 * //https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/comments/
 * //    https://www.iteye.com/blog/2751459205-2181764
 */

@Test
    public void t3() {
        //test array
        String[] strs = new String[]{"a", "a", "a", "b", "b", "c", "a"};
        findDuplicateAndSortByCounter(strs);
    }

    private void findDuplicateAndSortByCounter(String[] strs) {
        //use map store string and counter
        Map<String, Integer> c_map = new HashMap();

        for (String s : strs) {
            Integer count = c_map.get(s);
            c_map.put(s, (count == null ? 1 : count + 1));
        }

        //将map转化成list，实现Compare接口。
        List<Map.Entry<String, Integer>> entries = new ArrayList(c_map.entrySet());
        Collections.sort(entries, (o1, o2) -> o1.getValue() - o2.getValue());

        for(int i = 0; i < entries.size(); i++) {
            Map.Entry<String, Integer> entry =  entries.get(i);
            System.out.println(String.format("key: %s, value:%s", entry.getKey(), entry.getValue()));
        }
    }
```





## 合并两个有序数组（数组）

``` java
package com.future.algorithm;

import org.junit.jupiter.api.Test;

import java.util.Arrays;

/**
 * 合并两个有序数组
 * [1,2,3,0,0,0]  m=3  [2,4,5,6]  n=4
 * 给定两个"非递减顺序排列"的整数数组num1 和 num2, 另有两个整数m和n，
 * 分别代码两个数组中的元素的个数，请你合并nums2到nums1，并且使合并后的
 * 数组同样也按非递减顺序排列。
 * 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
 * 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
 * 输出：[1,2,2,3,5,6]
 * 解释：需要合并 [1,2,3] 和 [2,5,6] 。
 * 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
 * https://leetcode-cn.com/problems/merge-sorted-array/solution/he-bing-liang-ge-you-xu-shu-zu-by-leetco-rrb0/
 */
public class MergeSortArray {
    @Test
    public void t1() {
        int[] nums1 = new int[]{1, 2, 3, 0, 0, 0};
        int[] nums2 = new int[]{3, 5, 6};
        int m = 3, n = 3;

        mergex(nums1, m, nums2, n);
        System.out.println(Arrays.toString(nums1));
    }

    /**
     * 直接排序
     * 时间复杂度为：O((m+n)log(m+n))
     * 排序序列长度为 m+n，套用快速排序的时间复杂度即可，平均情况为 O((m+n)log(m+n))。
     * 空间复杂度：O(log(m+n))。
     * 排序序列长度为 m+n，套用快速排序的空间复杂度即可，平均情况为 O(log(m+n))。
     */
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i != n; ++i) {
            nums1[m + i] = nums2[i];
        }
        Arrays.sort(nums1);
    }

    /**
     * 双指针：利用已排序特性，我们可以使用双指针方法。这一方法将两个数组看作队列，
     * 每次从两个数组头部取出比较小的数字放到结果中。
     * 时间复杂度：O(m+n)
     * 指针移动，单调递增，最多移动O(m+n)
     * 空间复杂度：o(m+n)
     * 需要建立中间数组sorted
     */
    public void mergex(int[] nums1, int m, int[] nums2, int n) {
        // TODO: 4/11/22 add bound logic
        if (m == 0) {
        }
        if (n == 0) {
            return;
        }
        // TODO: 4/11/22 add result define sorted
        int[] sorted = new int[m + n];

        // TODO: 4/11/22 add pointer p1,p2
        int p1 = 0, p2 = 0, cur;
        while (p1 < m || p2 < n) {
            if (p1 == m) {
                cur = nums2[p2++];
            } else if (p2 == n) {
                cur = nums1[p1++];
            } else if (nums1[p1] < nums2[p2]) {
                cur = nums1[p1++];
            } else {
                cur = nums2[p2++];
            }
            sorted[p1 + p2 - 1] = cur;
        }

        // TODO: 4/11/22  return nums1 = sorted
        for (int i = 0; i != m + n; ++i) {
            nums1[i] = sorted[i];
        }
    }

}

```



##  向数组中追加 K 个整数(2195)



``` java
/**
 * Title  2195. 向数组中追加 K 个整数]
 * 给你一个整数数组 nums 和一个整数 k 。请你向 nums 中追加 k 个 未 出现在 nums 中的、互不相同 的 正 整数，并使结果数组的元素和 最小 。
 * 返回追加到 nums 中的 k 个整数之和。
 * <p>
 * 输入：nums = [1,4,25,10,25], k = 2
 * 输出：5
 * 解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。
 * nums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。
 * 所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。
 * <p>
 * 链接：https://leetcode.cn/problems/append-k-integers-with-minimal-sum
 * 提示：
 * 1 <= nums.length <= 105
 * 1 <= nums[i], k <= 109
 */
public class Solution2195 {
@Test
    public void t1() {
        int[] nums = new int[]{1, 4, 25, 10, 25};
        int k = 2, k1 = 3, k2 = 4;

        assertEquals(5, minimalKSum(nums, k));
        assertEquals(10, minimalKSum(nums, k1));
        assertEquals(16, minimalKSum(nums, k2));
    }
  
  //O(n)
    //易理解
    //执行用时：32 ms, 在所有 Java 提交中击败了43.46%的用户
    //https://leetcode.cn/problems/append-k-integers-with-minimal-sum/solution/xiang-shu-zu-zhong-zhui-jia-k-ge-zheng-s-9vdv/
    public long minimalKSum(int[] nums, int k) {
        int next = k + 1;
        long r = (1L + k) * k / 2;

        Set<Integer> sets = new HashSet();
        for (int num : nums) {
            sets.add(num);
        }

        for (int num : sets) {
            if (num <= k) {
                while (sets.contains(next)) {
                    next++;
                }
                r = r - num + next;
                next++;
            }
        }
        return r;
    }
}
```







[
第10 题翻转句子中单词的顺序](https://www.cnblogs.com/pg-love/archive/2011/07/24/2115520.html)



[第3题求子数组的最大和](https://www.cnblogs.com/pg-love/archive/2011/07/24/2115377.html)



[经典算法题--求对策字符串的最大长度](https://www.cnblogs.com/pg-love/archive/2011/07/23/2114869.html)



https://www.jianshu.com/p/6db5e1ae81d1







# 微软面试算法题总结

Leecode 84

 

第一题是数字三角形找最大和路径                             （容易题）

第二题是二叉树中找两个节点的最近公共祖先节点   （最近公共祖先）

 

给定二叉树中的特定节点中序遍历后的下一个节点 （剑指offer)

 

 u

Leetcode 124 最大路径和




做题       （并查集）

有n个二维平面上的点和距离d，将它们分成k组。

若两点间的距离小于等于d，则这两个点在一组；如果点A和点B在一组，点B和点C在一组，则点A和点C在一组。

算法返回每个点所在组的编号(0..k-1)

 

4.最长回文子串
5.中序遍历的下一个子节点

 

单链表逆序
二进制转十进制，考虑溢出

二叉树：当前节点的值更新为当前节点所有子节点的值之和（递归和非递归）



## 微软算法高频题

| 题目                                           | 出现次数 | 链接                                                         |
| ---------------------------------------------- | -------- | ------------------------------------------------------------ |
| 215. 数组中的第K个最大元素                     | 14       | https://leetcode-cn.com/problems/kth-largest-element-in-an-array |
| 236. 二叉树的最近公共祖先                      | 10       | https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree |
| 206. 反转链表                                  | 9        | https://leetcode-cn.com/problems/reverse-linked-list         |
| 48. 旋转图像                                   | 9        | https://leetcode-cn.com/problems/rotate-image                |
| 124. 二叉树中的最大路径和                      | 7        | https://leetcode-cn.com/problems/binary-tree-maximum-path-sum |
| 53. 最大子序和                                 | 7        | https://leetcode-cn.com/problems/maximum-subarray            |
| 91. 解码方法                                   | 6        | https://leetcode-cn.com/problems/decode-ways                 |
| 151. 翻转字符串里的单词                        | 6        | https://leetcode-cn.com/problems/reverse-words-in-a-string   |
| 543. 二叉树的直径                              | 6        | https://leetcode-cn.com/problems/diameter-of-binary-tree     |
| 297. 二叉树的序列化与反序列化                  | 6        | https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree |
| 146. LRU缓存机制                               | 5        | https://leetcode-cn.com/problems/lru-cache                   |
| 450. 删除二叉搜索树中的节点                    | 5        | https://leetcode-cn.com/problems/delete-node-in-a-bst        |
| 22. 括号生成                                   | 5        | https://leetcode-cn.com/problems/generate-parentheses        |
| 47. 全排列 II                                  | 5        | https://leetcode-cn.com/problems/permutations-ii             |
| 224. 基本计算器                                | 5        | https://leetcode-cn.com/problems/basic-calculator            |
| 468. 验证IP地址                                | 4        | https://leetcode-cn.com/problems/validate-ip-address         |
| 110. 平衡二叉树                                | 4        | https://leetcode-cn.com/problems/balanced-binary-tree        |
| 94. 二叉树的中序遍历                           | 4        | https://leetcode-cn.com/problems/binary-tree-inorder-traversal |
| 15. 三数之和                                   | 4        | https://leetcode-cn.com/problems/3sum                        |
| 121. 买卖股票的最佳时机                        | 4        | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock |
| 39. 组合总和                                   | 4        | https://leetcode-cn.com/problems/combination-sum             |
| 1. 两数之和                                    | 4        | https://leetcode-cn.com/problems/two-sum                     |
| 3. 无重复字符的最长子串                        | 4        | https://leetcode-cn.com/problems/longest-substring-without-repeating-characters |
| 207. 课程表                                    | 4        | https://leetcode-cn.com/problems/course-schedule             |
| 138. 复制带随机指针的链表                      | 4        | https://leetcode-cn.com/problems/copy-list-with-random-pointer |
| 69. x 的平方根                                 | 4        | https://leetcode-cn.com/problems/sqrtx                       |
| 240. 搜索二维矩阵 II                           | 4        | https://leetcode-cn.com/problems/search-a-2d-matrix-ii       |
| 4. 寻找两个正序数组的中位数                    | 3        | https://leetcode-cn.com/problems/median-of-two-sorted-arrays |
| 103. 二叉树的锯齿形层次遍历                    | 3        | https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal |
| 560. 和为K的子数组                             | 3        | https://leetcode-cn.com/problems/subarray-sum-equals-k       |
| 162. 寻找峰值                                  | 3        | https://leetcode-cn.com/problems/find-peak-element           |
| 62. 不同路径                                   | 3        | https://leetcode-cn.com/problems/unique-paths                |
| 72. 编辑距离                                   | 3        | https://leetcode-cn.com/problems/edit-distance               |
| 200. 岛屿数量                                  | 3        | https://leetcode-cn.com/problems/number-of-islands           |
| 89. 格雷编码                                   | 3        | https://leetcode-cn.com/problems/gray-code                   |
| 98. 验证二叉搜索树                             | 3        | https://leetcode-cn.com/problems/validate-binary-search-tree |
| 152. 乘积最大子数组                            | 3        | https://leetcode-cn.com/problems/maximum-product-subarray    |
| 384. 打乱数组                                  | 3        | https://leetcode-cn.com/problems/shuffle-an-array            |
| 37. 解数独                                     | 3        | https://leetcode-cn.com/problems/sudoku-solver               |
| 36. 有效的数独                                 | 3        | https://leetcode-cn.com/problems/valid-sudoku                |
| 面试题 08.12. 八皇后                           | 3        | https://leetcode-cn.com/problems/eight-queens-lcci           |
| 141. 环形链表                                  | 3        | https://leetcode-cn.com/problems/linked-list-cycle           |
| 153. 寻找旋转排序数组中的最小值                | 3        | https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array |
| 33. 搜索旋转排序数组                           | 3        | https://leetcode-cn.com/problems/search-in-rotated-sorted-array |
| 剑指 Offer 46. 把数字翻译成字符串              | 2        | https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof |
| 415. 字符串相加                                | 2        | https://leetcode-cn.com/problems/add-strings                 |
| 986. 区间列表的交集                            | 2        | https://leetcode-cn.com/problems/interval-list-intersections |
| 547. 省份数量（原朋友圈）                      | 2        | https://leetcode-cn.com/problems/number-of-provinces         |
| 34. 在排序数组中查找元素的第一个和最后一个位置 | 2        | https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array |
| 142. 环形链表 II                               | 2        | https://leetcode-cn.com/problems/linked-list-cycle-ii        |
| 154. 寻找旋转排序数组中的最小值 II             | 2        | https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii |
| 283. 移动零                                    | 2        | https://leetcode-cn.com/problems/move-zeroes                 |
| 10. 正则表达式匹配                             | 2        | https://leetcode-cn.com/problems/regular-expression-matching |
| 79. 单词搜索                                   | 2        | https://leetcode-cn.com/problems/word-search                 |
| 剑指 Offer 52. 两个链表的第一个公共节点        | 2        | https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof |
| 76. 最小覆盖子串                               | 2        | https://leetcode-cn.com/problems/minimum-window-substring    |
| 449. 序列化和反序列化二叉搜索树                | 2        | https://leetcode-cn.com/problems/serialize-and-deserialize-bst |
| 300. 最长上升子序列                            | 2        | https://leetcode-cn.com/problems/longest-increasing-subsequence |
| 剑指 Offer 33. 二叉搜索树的后序遍历序列        | 2        | https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof |
| 剑指 Offer 04. 二维数组中的查找                | 2        | https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof |
| 剑指 Offer 51. 数组中的逆序对                  | 2        | https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof |
| 877. 石子游戏                                  | 2        | https://leetcode-cn.com/problems/stone-game                  |
| 59. 螺旋矩阵 II                                | 2        | https://leetcode-cn.com/problems/spiral-matrix-ii            |
| 25. K 个一组翻转链表                           | 2        | https://leetcode-cn.com/problems/reverse-nodes-in-k-group    |
| 287. 寻找重复数                                | 2        | https://leetcode-cn.com/problems/find-the-duplicate-number   |
| 362. 敲击计数器                                | 2        | https://leetcode-cn.com/problems/design-hit-counter          |
| 119. 杨辉三角 II                               | 2        | https://leetcode-cn.com/problems/pascals-triangle-ii         |
| 863. 二叉树中所有距离为 K 的结点               | 2        | https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree |
| 1095. 山脉数组中查找目标值                     | 2        | https://leetcode-cn.com/problems/find-in-mountain-array      |
| 295. 数据流的中位数                            | 2        | https://leetcode-cn.com/problems/find-median-from-data-stream |
| 8. 字符串转换整数 (atoi)                       | 2        | https://leetcode-cn.com/problems/string-to-integer-atoi      |
| 129. 求根到叶子节点数字之和                    | 2        | https://leetcode-cn.com/problems/sum-root-to-leaf-numbers    |
| 173. 二叉搜索树迭代器                          | 2        | https://leetcode-cn.com/problems/binary-search-tree-iterator |
| 73. 矩阵置零                                   | 2        | https://leetcode-cn.com/problems/set-matrix-zeroes           |
| 补充题12. 二叉树的下一个节点                   | 2        | https://mp.weixin.qq.com/s/yewlHvHSilMsrUMFIO8WAA            |
| 补充题6. 手撕堆排序                            | 2        | https://leetcode-cn.com/problems/sort-an-array               |
| 148. 排序链表                                  | 2        | https://leetcode-cn.com/problems/sort-list                   |
| 208. 实现 Trie (前缀树)                        | 2        | https://leetcode-cn.com/problems/implement-trie-prefix-tree  |
| 706. 设计哈希映射                              | 2        | https://leetcode-cn.com/problems/design-hashmap              |
| 160. 相交链表                                  | 2        | https://leetcode-cn.com/problems/intersection-of-two-linked-lists |
| 428. 序列化和反序列化 N 叉树                   | 2        | https://leetcode-cn.com/problems/serialize-and-deserialize-n-ary-tree |
| 64. 最小路径和                                 | 2        | https://leetcode-cn.com/problems/minimum-path-sum            |
| 116. 填充每个节点的下一个右侧节点指针          | 2        | https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node |
| 105. 从前序与中序遍历序列构造二叉树            | 2        | https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal |
| 40. 组合总和 II                                | 2        | https://leetcode-cn.com/problems/combination-sum-ii          |
| 189. 旋转数组                                  | 2        | https://leetcode-cn.com/problems/rotate-array                |
| 84. 柱状图中最大的矩形                         | 1        | https://leetcode-cn.com/problems/largest-rectangle-in-histogram |
| 120. 三角形最小路径和                          | 1        | https://leetcode-cn.com/problems/triangle                    |
| 5. 最长回文子串                                | 1        | https://leetcode-cn.com/problems/longest-palindromic-substring |
| 867. 转置矩阵                                  | 1        | https://leetcode-cn.com/problems/transpose-matrix            |
| 78. 子集                                       | 1        | https://leetcode-cn.com/problems/subsets                     |
| 907. 子数组的最小值之和                        | 1        | https://leetcode-cn.com/problems/sum-of-subarray-minimums    |
| 1013. 将数组分成和相等的三个部分               | 1        | https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum |
| 572. 另一个树的子树                            | 1        | https://leetcode-cn.com/problems/subtree-of-another-tree     |
| 704. 二分查找                                  | 1        | https://leetcode-cn.com/problems/binary-search               |
| 171. Excel表列序号                             | 1        | https://leetcode-cn.com/problems/excel-sheet-column-number   |
| 150. 逆波兰表达式求值                          | 1        | https://leetcode-cn.com/problems/evaluate-reverse-polish-notation |
| 767. 重构字符串                                | 1        | https://leetcode-cn.com/problems/reorganize-string           |
| 459. 重复的子字符串                            | 1        | https://leetcode-cn.com/problems/repeated-substring-pattern  |
| 973. 最接近原点的 K 个点                       | 1        | https://leetcode-cn.com/problems/k-closest-points-to-origin  |
| 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面  | 1        | https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof |
| 剑指 Offer 36. 二叉搜索树与双向链表            | 1        | https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof |
| 887. 鸡蛋掉落                                  | 1        | https://leetcode-cn.com/problems/super-egg-drop              |
| 剑指 Offer 26. 树的子结构                      | 1        | https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof      |
| 328. 奇偶链表                                  | 1        | https://leetcode-cn.com/problems/odd-even-linked-list        |
| 137. 只出现一次的数字 II                       | 1        | https://leetcode-cn.com/problems/single-number-ii            |
| 155. 最小栈                                    | 1        | https://leetcode-cn.com/problems/min-stack                   |
| 1375. 灯泡开关 III                             | 1        | https://leetcode-cn.com/problems/bulb-switcher-iii           |
| 662. 二叉树最大宽度                            | 1        | https://leetcode-cn.com/problems/maximum-width-of-binary-tree |
| 44. 通配符匹配                                 | 1        | https://leetcode-cn.com/problems/wildcard-matching           |
| 739. 每日温度                                  | 1        | https://leetcode-cn.com/problems/daily-temperatures          |
| 122. 买卖股票的最佳时机 II                     | 1        | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii |
| 20. 有效的括号                                 | 1        | https://leetcode-cn.com/problems/valid-parentheses           |
| 700. 二叉搜索树中的搜索                        | 1        | https://leetcode-cn.com/problems/search-in-a-binary-search-tree |
| 701. 二叉搜索树中的插入操作                    | 1        | https://leetcode-cn.com/problems/insert-into-a-binary-search-tree |
| 1312. 让字符串成为回文串的最少插入次数         | 1        | https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome |
| 139. 单词拆分                                  | 1        | https://leetcode-cn.com/problems/word-break                  |
| 557. 反转字符串中的单词 III                    | 1        | https://leetcode-cn.com/problems/reverse-words-in-a-string-iii |
| 60. 第k个排列                                  | 1        | https://leetcode-cn.com/problems/permutation-sequence        |
| 848. 字母移位                                  | 1        | https://leetcode-cn.com/problems/shifting-letters            |
| 569. 员工薪水中位数                            | 1        | https://leetcode-cn.com/problems/median-employee-salary      |
| 88. 合并两个有序数组                           | 1        | https://leetcode-cn.com/problems/merge-sorted-array          |
| 617. 合并二叉树                                | 1        | https://leetcode-cn.com/problems/merge-two-binary-trees      |
| 349. 两个数组的交集                            | 1        | https://leetcode-cn.com/problems/intersection-of-two-arrays  |
| 713. 乘积小于K的子数组                         | 1        | https://leetcode-cn.com/problems/subarray-product-less-than-k |
| 102. 二叉树的层序遍历                          | 1        | https://leetcode-cn.com/problems/binary-tree-level-order-traversal |
| 113. 路径总和 II                               | 1        | https://leetcode-cn.com/problems/path-sum-ii                 |
| 692. 前K个高频单词                             | 1        | https://leetcode-cn.com/problems/top-k-frequent-words        |
| 394. 字符串解码                                | 1        | https://leetcode-cn.com/problems/decode-string               |
| 1155. 掷骰子的N种方法                          | 1        | https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum |
| 694. 不同岛屿的数量                            | 1        | https://leetcode-cn.com/problems/number-of-distinct-islands  |
| 1314. 矩阵区域和                               | 1        | https://leetcode-cn.com/problems/matrix-block-sum            |
| 82. 删除排序链表中的重复元素 II                | 1        | https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii |
| 123. 买卖股票的最佳时机 III                    | 1        | https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii |
| 114. 二叉树展开为链表                          | 1        | https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list |
| 104. 二叉树的最大深度                          | 1        | https://leetcode-cn.com/problems/maximum-depth-of-binary-tree |
| 407. 接雨水 II                                 | 1        | https://leetcode-cn.com/problems/trapping-rain-water-ii      |
| 剑指 Offer 40. 最小的k个数                     | 1        | https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof    |
| 347. 前 K 个高频元素                           | 1        | https://leetcode-cn.com/problems/top-k-frequent-elements     |
| 剑指 Offer 31. 栈的压入、弹出序列              | 1        | https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof |
| 29. 两数相除                                   | 1        | https://leetcode-cn.com/problems/divide-two-integers         |
| 1356. 根据数字二进制下 1 的数目排序            | 1        | https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits |
| 386. 字典序排数                                | 1        | https://leetcode-cn.com/problems/lexicographical-numbers     |
| 311. 稀疏矩阵的乘法                            | 1        | https://leetcode-cn.com/problems/sparse-matrix-multiplication |
| 166. 分数到小数                                | 1        | https://leetcode-cn.com/problems/fraction-to-recurring-decimal |
| 补充题14. 阿拉伯数字转中文数字                 | 1        |                                                              |
| 21. 合并两个有序链表                           | 1        | https://leetcode-cn.com/problems/merge-two-sorted-lists      |
| 1358. 包含所有三种字符的子字符串数目           | 1        | https://leetcode-cn.com/problems/number-of-substrings-containing-all-three-characters |
| 剑指 Offer 53 - II. 0～n-1中缺失的数字         | 1        | https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof      |
| 补充题17. 两个有序数组第k小的数                | 1        |                                                              |
| 209. 长度最小的子数组                          | 1        | https://leetcode-cn.com/problems/minimum-size-subarray-sum   |
| 227. 基本计算器 II                             | 1        | https://leetcode-cn.com/problems/basic-calculator-ii         |
| 470. 用 Rand7() 实现 Rand10()                  | 1        | https://leetcode-cn.com/problems/implement-rand10-using-rand7 |
| 13. 罗马数字转整数                             | 1        | https://leetcode-cn.com/problems/roman-to-integer            |
| 643. 子数组最大平均数 I                        | 1        | https://leetcode-cn.com/problems/maximum-average-subarray-i  |
| 871. 最低加油次数                              | 1        | https://leetcode-cn.com/problems/minimum-number-of-refueling-stops |
| 1615. 最大网络秩                               | 1        | https://leetcode-cn.com/problems/maximal-network-rank        |
| 剑指 Offer 56 - II. 数组中数字出现的次数 II    | 1        | https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof |
| 1483. 树节点的第 K 个祖先                      | 1        | https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node |
| 1570. 两个稀疏向量的点积                       | 1        | https://leetcode-cn.com/problems/dot-product-of-two-sparse-vectors |
| 628. 三个数的最大乘积                          | 1        | https://leetcode-cn.com/problems/maximum-product-of-three-numbers |
| 145. 二叉树的后序遍历                          | 1        | https://leetcode-cn.com/problems/binary-tree-postorder-traversal |
| 46. 全排列                                     | 1        | https://leetcode-cn.com/problems/permutations                |
| 460. LFU缓存                                   | 1        | https://leetcode-cn.com/problems/lfu-cache                   |
| 785. 判断二分图                                | 1        | https://leetcode-cn.com/problems/is-graph-bipartite          |
| 718. 最长重复子数组                            | 1        | https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray |
| 242. 有效的字母异位词                          | 1        | https://leetcode-cn.com/problems/valid-anagram               |
| 307. 区域和检索 - 数组可修改                   | 1        | https://leetcode-cn.com/problems/range-sum-query-mutable     |
| 442. 数组中重复的数据                          | 1        | https://leetcode-cn.com/problems/find-all-duplicates-in-an-array |
| 补充题13. 中文数字转阿拉伯数字                 | 1        |                                                              |
| 56. 合并区间                                   | 1        | https://leetcode-cn.com/problems/merge-intervals             |
| 17. 电话号码的字母组合                         | 1        | https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number |
| 1143. 最长公共子序列                           | 1        | https://leetcode-cn.com/problems/longest-common-subsequence  |
| 179. 最大数                                    | 1        | https://leetcode-cn.com/problems/largest-number              |
| 513. 找树左下角的值                            | 1        | https://leetcode-cn.com/problems/find-bottom-left-tree-value |
| 133. 克隆图                                    | 1        | https://leetcode-cn.com/problems/clone-graph                 |
| 99. 恢复二叉搜索树                             | 1        | https://leetcode-cn.com/problems/recover-binary-search-tree  |
| 剑指 Offer 48. 最长不含重复字符的子字符串      | 1        | https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof |
| 168. Excel表列名称                             | 1        | https://leetcode-cn.com/problems/excel-sheet-column-title    |
| 2. 两数相加                                    | 1        | https://leetcode-cn.com/problems/add-two-numbers             |
| 337. 打家劫舍 III                              | 1        | https://leetcode-cn.com/problems/house-robber-iii            |
| 518. 零钱兑换 II                               | 1        | https://leetcode-cn.com/problems/coin-change-2               |
| 844. 比较含退格的字符串                        | 1        | https://leetcode-cn.com/problems/backspace-string-compare    |
| 353. 贪吃蛇                                    | 1        | https://leetcode-cn.com/problems/design-snake-game           |
| 198. 打家劫舍                                  | 1        | https://leetcode-cn.com/problems/house-robber                |
| 109. 有序链表转换二叉搜索树                    | 1        | https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree |
| 70. 爬楼梯                                     | 1        | https://leetcode-cn.com/problems/climbing-stairs             |
| 面试题 17.24. 最大子矩阵                       | 1        | https://leetcode-cn.com/problems/max-submatrix-lcci          |
| 268. 缺失数字                                  | 1        | https://leetcode-cn.com/problems/missing-number              |
| 1497. 检查数组对是否可以被 k 整除              | 1        | https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k |
| 239. 滑动窗口最大值                            | 1        | https://leetcode-cn.com/problems/sliding-window-maximum      |
| 354. 俄罗斯套娃信封问题                        | 1        | https://leetcode-cn.com/problems/russian-doll-envelopes      |
| 752. 打开转盘锁                                | 1        | https://leetcode-cn.com/problems/open-the-lock               |
| 797. 所有可能的路径                            | 1        | https://leetcode-cn.com/problems/all-paths-from-source-to-target |
| 222. 完全二叉树的节点个数                      | 1        | https://leetcode-cn.com/problems/count-complete-tree-nodes   |
| 322. 零钱兑换                                  | 1        | https://leetcode-cn.com/problems/coin-change                 |
| 743. 网络延迟时间                              | 1        | https://leetcode-cn.com/problems/network-delay-time          |
| 199. 二叉树的右视图                            | 1        | https://leetcode-cn.com/problems/binary-tree-right-side-view |
| 135. 分发糖果                                  | 1        | https://leetcode-cn.com/problems/candy                       |
| 41. 缺失的第一个正数                           | 1        | https://leetcode-cn.com/problems/first-missing-positive      |
| 剑指 Offer 15. 二进制中1的个数                 | 1        | https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof |
| 剑指 Offer 22. 链表中倒数第k个节点             | 1        | https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof |

# 腾讯春招

![image-20240308084916099](/Users/haibingzhang/Library/Application Support/typora-user-images/image-20240308084916099.png)





# 字节跳动面试算法

> https://zhuanlan.zhihu.com/p/336117700













