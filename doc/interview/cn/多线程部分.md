[toc]

# 原理部分

> 说明：
>
> 整体性：
> 理论基础->设计模式-> 并发工具-> 并发框架（mubu：多线程）
> 理论基础：JMM（可见性、有序性）
> 《java 并发编程实战》、极客时间

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h0sqo6i424j217q0u0772.jpg" alt="image-20220331080152020" style="zoom:100%;" />

# 多线程的多种设计模式

a .Future 模式：

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h28w24snd6j21l30u0qa9.jpg" alt="image-20220331080351190"  />

<img src="/Users/haibingzhang/d/weiyundata/typoradoc/images/image-20220331080435031.png" alt="image-20220331080435031"  />

b. 生产者和消费者模式

在生产者和消费者模式中通常有两类线程，生产者线程和消费者线程，生产者负责提交用户请求，消费者负责具体处理生产者提交的 请求。生产者和消费者通过共享缓冲区进行通信。

c. Master-worker 模式 

[https://time.geekbang.org/column/article/92524](https://time.geekbang.org/column/article/92524)

常用的并行模式之一。**核心思想**：系统中包含两类进程：master 进程和 worker 进程。master 进程负责接收和分配任务，worker 进程负责处理子任务。当各个 worker 进程将子任务处理完成后将部分结果返回给 master 进程，由其负责归纳和汇总从而得到最终的结果。

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h28w2b80wuj21id0u0did.jpg" alt="image-20220331231823847"  />

# JMM 指什么，JMM 底层如何实现？****

>《java 并发实战》- JMM
>[https://time.geekbang.org/column/article/13484](https://time.geekbang.org/column/article/13484)
>[https://time.geekbang.org/column/article/460545](https://time.geekbang.org/column/article/460545)
>[https://time.geekbang.org/column/article/464954](https://time.geekbang.org/column/article/464954)
>tengxunketang：java 内存模型与 volatile 关键字
>**Java 内存模型（JMM：Java Memory Model）：**

**为什么需要 JMM？（statuation）**

背景：因为程序的指令重排序可以在很大程度上==提升程序的性能==。Java 语言规范要求 JVM 在线程中维护一种类似串行的语义：只要程序的最终结果与在严格串行环境下执行的结果相同，这些操作都是被允许的，比如程序在编译器中的指令顺序可以与源代码中的顺序不同；处理器还可以乱序或并行等方式来执行指令等。

![image-20220514170323360](https://tva1.sinaimg.cn/large/e6c9d24ely1h281jyi2pgj20rc0bagmf.jpg)

**基本概念**：

* `JMM作用及目的`：用来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。目的是定义在程序中各个变量的访问规则。
* `JMM定义`：JMM规定了所有 的变量必须保存在主内存中。每条线程都有自己的工作内存。工作内存中保存了该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作都必须 在工作内存中进行，而不能直接读写主内存中的变量。
* JMM是围绕着在并发过程中如何解决变量的原子性、可见性和有序性这三个特征来建立的。
* `原子性`：由JMM来直接保证的原子性变量操作包括read、load、use、assign、store和write。可以认为==基本数据类型==的读写都是具备原子性的（除了float和double的非原子协定）。如果程序需要一个==更大原子性==的保证，JMM还提供了lock和unlock操作来满足这种需求。这个操作没有直接提供给用户，提供了更高层次的字节码指令monitorenter和 monitorexit，反映到java代码块就是synchronized关键字。因此，synchronized块之间操作也具备原子性。
* `可见性`：JMM是通过在变量修改后将新值==同步回主内存==，在变量读取 前==从主内存刷新变量==值这种依赖主内存的作为传递媒介的方式来实现可见性的。普通变量和volatile变量都是如此，区别就是volatile变量保证了新值能==立即同步回主内存==。扩展--除了volatile外，java还有两个关键字保证了可见性：`synchronized和final`。同步块的可见性: 是由对一个变量执行unlock操作之前必须先把此变量同步回主内存中这条规则获取的。final关键字的可见性是指：被修饰为final的字段在构造器中一旦完成初始化，并且没有被“this”的引用传递出去，那在其他的线程中就能看到final字段的值。（由哪个工作内存来修改主内存的值，是通过硬件的mesi等一致性协议来解决的）
* `有序性`：在一个线程内所有的操作都是有序的，也就是指线程内表现为==串行的语义==；在一个线程观察另外一个线程，所有的操作都是无序的，是指==“指令重排序”现象和“工作内存与主内存同步延迟”==现象。java语言提供==volatile和synchronized==两个关键字来保证线程间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获取的。除这两个关键字之外，java还提供了“==先行发生原则==”来完成jmm中所有的有序性。JMM 为程序中的所有操作定义了一种偏序关系，称之为 Happens-before。要想保证执行操作 B 的线程看到操作 A 的结果（无论 A、B是否在同一个线程中执行），那么在 A 和 B 之间必须满足 Happens-before 关系。如果两个操作之间缺少 Happens-before 关系，那么 JVM 可以对它们任意地重排序。(程序次序规则、管程锁定规则、volatile变量规则、线程启动-终止-中断规则)

**实现原理：**

* ==**内存屏障**==：Java 内存模型是通过内存屏障（memory barrier）来==禁止重排序==的。对于即时编译器来说，它会针对每一个 happens-before 关系，向正在编译的==目标方法中插入==相应的读读、读写、写读以及写写内存屏障。这些内存屏障会限制即时编译器的重排序操作。

* ==**依赖底层体系架构**==：即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。以我们日常接触的 X86_64 架构来说，读读、读写以及写写内存屏障是空操作（no-op），只有==写读==内存屏障会被替换成具体指令[2]。

  

知识扩展：

-  硬件缓存一致性如何解决？（MESI）
-  jmm实现类比高速缓存与主内存之间的交互
-  如何使处理器内部的运算单元尽量充分利用？  高速缓存、处理器对代码乱序执行(out-of-order)(但计算任务依赖执行结果时需要保障顺序)

（待深入理解：然而，在 X86_64 架构上，只有 volatile 字段写操作之后的写读内存屏障需要用具体指令来替代。（HotSpot 所选取的具体指令是 lock add DWORD PTR [rsp],0x0，而非 mfence[3]。）该具体指令的效果，可以简单理解为强制刷新处理器的写缓存。写缓存是处理器用来加速内存存储效率的一项技术。在碰到内存写操作时，处理器并不会等待该指令结束，而是直接开始下一指令，并且依赖于写缓存将更改的数据同步至主内存（main memory）之中。强制刷新写缓存，将使得当前线程写入 volatile 字段的值（以及写缓存中已有的其他内存修改），同步至主内存之中。由于内存写操作同时会无效化其他处理器所持有的、指向同一内存地址的缓存行，因此可以认为其他处理器能够立即见到该 volatile 字段的最新值。）

![image-20220331231925566](https://tva1.sinaimg.cn/large/e6c9d24ely1h28w2i2on2j21ai0u041a.jpg)



![image-20220331231949558](https://tva1.sinaimg.cn/large/e6c9d24ely1h28w2pnrwxj21p50u044a.jpg)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h28w2wnz2vj20r40omjsv.jpg)



# Java 中的 volatile 关键字的作用？//todo

>[https://www.infoq.cn/article/ftf-java-volatile/](https://www.infoq.cn/article/ftf-java-volatile/)
>[http://ifeve.com/volatile/](http://ifeve.com/volatile/)
>保证有序性（防止指令重排序）和可见性、。

* **有序性：**以 volatile 字段访问为例，所插入的内存屏障将不允许 volatile 字段写操作之前的内存访问被重排序至其之后；也将不允许 volatile 字段读操作之后的内存访问被重排序至其之前。对于 volatile 字段，即时编译器将在 volatile 字段的读写操作前后各插入一些内存屏障来防止指令重排。
* **可见性**：在 X86_64 体系架构上，只有 volatile 字段写操作之后的写读内存屏障需要用具体指令来替代。该具体指令的效果，可以简单理解为==强制刷新处理器的写缓存==。由于内存写操作同时会无效化其他处理器所持有的、指向同一内存地址的缓存行，因此可以认为其他处理器能够立即见到该 volatile 字段的最新值。（**绕过了 cpu 高速缓存**）
* **性能好：**Volatile 变量修饰符如果使用恰当的话，它比 synchronized 的使用执行成本会更低，因为它不会引起线程上下文的切换和调度。volatile 降低了加锁的粒度，提高了整体操作的性能。（以往总线加锁：从 read->load->use...->write。volatile 加锁：从回写的 store->write ）
* ![image-20220331232054021](https://tva1.sinaimg.cn/large/e6c9d24ely1h28w317sgxj21pk0u0wk9.jpg)

4. JMM 应用举例之一：AQS   *****

>[https://time.geekbang.org/column/article/464954](https://time.geekbang.org/column/article/464954)
>没太明白具体实例
>Java 并发库中的核心数据结构 AbstractQueuedSynchronizer(AQS)，它通过使用 volatile 变量和原子操作来维护对象的状态。

5.  JMM 应用举例二：如何高效地实现线程安全的单例模式？（需更深入的理解//todo）

>[https://time.geekbang.org/column/article/464954](https://time.geekbang.org/column/article/464954)

```java
//懒汉式  double check
class Singleton {
    // 非核心代码略
    private static Singleton instance = new Singleton();
    private Singleton() { a = 1; }
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null)
                    instance = new Singleton();  //第 8 行
            }
        }
        return instance;
    }
}
```

* 实现线程安全的单例模式。我们梳理了单例模式的各种实现方式，并详细介绍了 double check 实现方式的问题：**写后写的乱序执行**

```plain
这个写法在多核体系结构上还是会出现问题的。假设线程 1 执行到第 8 行，在创建 
Singleton 变量的时候，由于没有 Happens-Before 的约束，所以 instance 变量和 
instance.a 变量的赋值的先后顺序就不能保证了。(除非 a 定义为 final，保证初始化过程的安全性)
如果这时线程 2 调用了 getInstance，它可能看到 instance 的值不是 null，但是 
instance.a 的值仍然是一个未初始化的值，也就是说线程 2 看到了 instance 和 
instance.a 这两个变量的赋值乱序执行了。
```

线程 2 看到了 instance 和 instance.a 这两个变量的赋值乱序执行了。也就是初始化的过程不是安全的。

* 使用 volatile 来修复：只需要将 instance 变量加上 volatile 关键字(即可把这个变量的读变成 acquire 读，写变成 release 写)这样，我们才真正地正确实现了饿汉式和懒汉式的单例模式。



# 在 Java 中 CycliBarriar 和 CountdownLatch 有什么区别？***

>[https://time.geekbang.org/column/article/89461](https://time.geekbang.org/column/article/89461)

* **主要区别**：countdownlatch 主要用来解决**一个线程等待多个线程**的场景，可以类比旅游团长等待所有游客到齐以后才能去到下一个景点。CyclicBarriar 是一组**线程间的相互等待**，可以类比驴友间的互相等待。

  <img src="/Users/haibingzhang/d/weiyundata/typoradoc/images/image-20220331232134666.png" alt="image-20220331232134666"  />

* **循环利用**：countdownlatch 计数器**不能循环使用**，一旦计数器减到 0，再调用 await 方法，线程会直接通过。cyclicBarriar 计数器是可以**循环利用**，而且具有**自动重置**功能，一旦计数器减到 0 会自动重置到你设置的初始值。cyclicBarriar 还可以设置**回调函数**。
  cyclicBarriar

* <img src="/Users/haibingzhang/d/weiyundata/typoradoc/images/e6c9d24ely1h0th8owp55j20u00yd400.jpg" alt="image-20220331232227969"  />

# stampLock vs ReadWriteLock 

* ReadWriteLock 支持两种模式：一种是读锁，一种是写锁。
* StampedLock 
  * **支持三种模式**：写锁、悲观读锁和乐观读。其中，写锁、悲观读锁的语义和 ReadWriteLock 的写锁、读锁的语义非常类似，允许多个线程同时获取悲观读锁，但是只允许一个线程获取写锁，写锁和悲观读锁是互斥的。
  * **stamp 作用**：StampedLock 里的写锁和悲观读锁加锁成功之后，都会返回一个 stamp；然后解锁的时候，需要传入这个 stamp。
* **对比：StampedLock 的性能之所以比 ReadWriteLock 还要好**，其关键是 StampedLock 支持乐观读的方式(乐观读这个操作是无锁的)。ReadWriteLock 支持多个线程同时读，但是当多个线程同时读的时候，所有的写操作会被阻塞；而 StampedLock 提供的乐观读，是允许一个线程获取写锁的，也就是说不是所有的写操作都被阻塞。

# 如果线程阻塞在 StampedLock 的 readLock() 或者 writeLock() 上时，此时调用该阻塞线程的 interrupt() 方法，会导致 CPU 飙升 *****

>[https://time.geekbang.org/column/article/89456](https://time.geekbang.org/column/article/89456) ss

* StampedLock 内太多的自旋引起：如果没有中断，那么阻塞在 readLock()上的线程在经过几次自旋后，会进入 park()等待，一旦进入 park()等待，就不会占用 CPU 了。一旦线程被中断，park()就会立即返回，锁未准备好时，就会一直自旋，导致 cpu 飙升。
* 建议：使用 StampedLock 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 readLockInterruptibly() 和写锁 writeLockInterruptibly()。

# ThreadLocal 起什么作用？实现原理、应用场景？

[https://www.bilibili.com/video/BV1fA411b7SX?from=search&seid=16979698387429561779&spm_id_from=333.337.0.0](https://www.bilibili.com/video/BV1fA411b7SX?from=search&seid=16979698387429561779&spm_id_from=333.337.0.0)

* **概念特性**：Threadlocal 为每个使用变量的线程提供了一份独立的变量副本。这种变量在线程的生命周期内起作用，减少了同一个线程内多个函数或者组件之间一些公共变量传递的复杂性。
* 实现原理：每一个线程都有自己的 ThreadLocalMap 对象，可以将线程自己的对象保存其中，线程可以正确的访问到自己的对象。
* 将一个公共的 threadlocal 静态实例作为 key，将不同的对象引用保存到不同的线程的 ThreadLocalMap 中，通过 get 方法获取。（继承自 weakReference，key 自动回收，value 不 自动 回收，会导致内存泄漏）

# volatile 能代替锁吗？这段代码能输出 80000 吗？

不能。

* volatile 不能代替锁，它是绕过 CPU 高速缓存，直接与内存进行交互并读写数据。
* 当多线程时，会存在线程 A 将新值写入内存前，线程 B 又从内存读取了旧值，这样就会导致 sum 的值不会是 80000。
* 要想 sum 的值为 80000，还得给 Main.sum += 1;这句代码加锁或采用 cas 操作或数据结构（atomicInteger）。

```java
public class Main {
  
    public static int sum;
    @Test
    public void t1() throws InterruptedException {
        AThread t1 = new AThread();
        AThread t2 = new AThread();
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(Main.sum);
    }
}
class AThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 40000; i++) {
            synchronized (AThread.class) {
                Main.sum += 1;
            }
        }
    }
}
```







# 分布式锁的原理。

# LinkedHashmap 的底层实现

# 类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么 处理的？如果加了字段会怎么样？

# Override 和 Overload 的区别，分别用在什么场景

# java 的反射是如何实现的

视频参考：

* [https://www.bilibili.com/video/av968800669](https://www.bilibili.com/video/av968800669)





# synchronized同步锁的原理

> synchronized如何使用？
>
> 同步锁的原理是什么样的？
>
> jdk1.6 是如何进行优化的？

- synchronized可以同步方法和同步块，源代码和字节码如下：

``` java
//源代码
  public synchronized void method1() {
      // code
  }
  
  // 关键字在代码块上，锁为括号里面的对象
  public void method2() {
      Object o = new Object();
      synchronized (o) {
          // code
      }
  }


//method2的字节码
public void method2(); 
descriptor: ()V 
flags: ACC_PUBLIC 
Code: 
  stack=2, locals=4, args_size=1 
    0: new #2 
    3: dup 
    4: invokespecial #1 
    7: astore_1 
    8: aload_1 
    9: dup 
    10: astore_2 
    11: monitorenter //monitorenter 指令 
    12: aload_2 
    13: monitorexit //monitorexit 指令
    
//method1的字节码
public synchronized void method1(); 
descriptor: ()V 
flags: ACC_PUBLIC, ACC_SYNCHRONIZED // ACC_SYNCHRONIZED 标志 
Code: 
	stack=0, locals=1, args_size=1 
		0: return 
	LineNumberTable: 
		line 8: 0
```

- synchronized修饰方法块时是通过monitorenter和monitoreixt指令实现同步互斥的。修饰方法时是通过判断是否存在标志位acc_synchronized来实现的。
- JVM同步锁是通过进入和退出管程来实现的。每个对象都有一个监视器（monitor），monitor与对象一起创建和销毁。monitor是由ObjectMonitor实现的，后者由C++编写的ObjectMonitor.hpp实现。ObjectMonitor中包含connectionList和 _EntryList。
- 多线程访问同步代码时，被阻塞的线程存储在connectionList和__EntryList中。获取monitor的线程，底层通过获取mutex lock来进行加锁。然后执行方法。



## AQS的原理是什么样的？ 源码角度的进行描述一下？

AQS（AbstractQueuedSynchronizer）是Java并发包中提供的一个底层框架，主要用于构建锁或者其他形式的同步器。AQS的核心原理基于CLH（Craig, Landin, and Hagersten）队列锁的思想，并结合了CAS（Compare And Swap）无锁算法，实现了高效的线程同步。

以下是AQS的主要原理与源码层面的描述：

1. 状态变量state： AQS维护了一个volatile的int类型的变量state，它是同步状态的标志，通过CAS操作更新state来实现线程的获取和释放锁。例如，如果是独占锁，state=0表示锁空闲，state=1表示已持有锁。
1. 内部FIFO等待队列： AQS内部使用了一个双向链表作为等待队列，节点（Node）代表等待获取锁的线程。当线程尝试获取锁失败时，会被封装成Node节点加入到等待队列尾部，遵循FIFO原则。
3. CAS操作： AQS利用Unsafe类提供的CAS操作，无锁地更新state变量，只有当期望值等于当前值时才会更改state。这能够保证在多线程环境下安全地更新同步状态，减少了锁的开销。
4. 获取锁与释放锁：
获取锁：子类通过调用tryAcquire(int arg)方法尝试获取锁，此方法由各个同步组件自行实现，根据不同的同步需求来判断是否能获取到锁。若获取失败，会调用addWaiter(Node.EXCLUSIVE)方法将当前线程封装成Node加入等待队列，并进入parkAndCheckInterrupt()方法挂起当前线程。
5. 释放锁：子类调用自己的tryRelease(int arg)方法尝试释放锁，成功后会唤醒等待队列中的首节点对应的线程。唤醒过程是由unparkSuccessor(Node node)方法负责的，它会找到下一个应该被唤醒的节点并恢复其运行。
6. 自旋与阻塞： 在尝试获取锁失败后，AQS还支持自旋等待一段时间，尝试重新获取锁，减少线程上下文切换的成本。在自旋次数达到一定阈值或条件不允许自旋时，线程会被放入等待队列并阻塞。
7. 中断与超时： AQS还支持中断等待的线程和超时获取锁的功能，当线程被中断或等待超时时，AQS会处理相应的逻辑并抛出InterruptedException或返回false。

总结来说，AQS通过state变量和内部等待队列的设计，配合CAS操作实现了线程间的高效同步，其灵活的框架设计允许开发者根据实际需求定制各种同步器，如ReentrantLock、Semaphore、CountDownLatch等。



