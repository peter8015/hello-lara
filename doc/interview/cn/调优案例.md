[toc]





> 说明：做到精通系统调优，实际工作经验总结。

# todo

- 深度梳理-极客



# 性能优化的分析技巧有什么？

* 寻找性能优化的机会
    * 使用高效的算法
    * 减少锁竞争
    * 为算法生成更有效率的代码
* 减少系统态CPU的使用
    * 监控操作系统在系统或内核态CPU的使用情况
    * 减少I/O系统调用的频率
        * 缓存数据
        * 批量的读取或写入
        * 使用java NIO非阻塞的数据结构
* 减少锁争用方法
    * 使用JAVA原子并发的数据结构
    * 合理设计应用程序，尽量降低多线程访问同一数据频率、缩小并发访问的范围。
* 合理的定义Volatitle字段
* 调整数据结构的大小
* 增加并行性
* 查看timeline

# java编程性能优化

- 字符串调优

- 慎用正则表达式

- ArrayList 和 LinkedList 性能差千培

- stream高效遍历

- 高并发下的io瓶颈

- 避免java序列化

- 优化rpc网络通信

# 多线程性能优化

- JMM内存模型
- 锁优化：Synchronized同步锁的优化；lock同步锁的优化；乐观锁优化并行操作

- 多线程调优：哪些操作导致上下文切换？如何优化？

- 并发容器的使用：不同场景下的最优容器。

- 如何设置线程池大小。

- 线程池的选择，complableFuture、CompletionService  

# JVM性能调优

## 基础原理

- GC过程，GC回收器的选择
- java内存模型
- 优化编译
- 优化jvm内存分配 
- 内存持续上升，应该如何排查？

## JVM性能优化的原则是什么？

* ==MinorGC回收原则==：每次MinorGC都尽可能多的收集垃圾对象
* ==GC内存最大化原则==：处理吞吐量和延迟问题时， 垃圾收集器能使用的内存越大，处理效果越好。
* ==GC调优的3选2原则==：吞吐量、延迟、占用内存任意选择两个进行JVM垃圾收集器调优

## JVM性能优化技巧有什么 @@@@

常用的调优的案例和方法

* 将新对象预留在新生代
* 大对象直接进入老年代
* 设置对象进入老年代的年龄
* 稳定和震荡的堆大小
* 吞吐量优化案例
* 使用大页案例
* 降低停顿案例
# 设计模式调优

- 单例模式

- 原型与享元

- 如何使用设计模式优化并发编程

- 电商库存设计优化：生产者、消费者

- 装饰器模式：如何优化电商系统中复杂的商品价格策略

# 数据库性能调优

## 一些疑问 //todo

- 如何迁移数据？特别是有运行中的应用时？
- 如何做数据的备份？
- 如何做数据的异地备份？
- 如何解决数据的一致性问题？
- 大数据架构？
- 全同步复制，主从、从从如何交互同步？半同步复制，未返回ack的库如何提供服务？

## 数据库调优措施

> 问题：无索引、索引失效、锁等待（死锁、锁升级）
>
> 参考：mysql



# athas

应用场景：

- 线上代码是否生效问题：我明明改了代码，为什么线上不生效{jad com.xxx.xxx}
- 遇到线上问题，又不能DEBUG，有没有日志，怎么办，重新加日志然后发包？{watch com.xxx.xxx.(类名) execute(方法名) params(表示监听该方法的参数)}
- 线上某个数据处理有问题，线下又不能复现，只能线上监视。
- 内存使用情况，线上可以监控JVM运行情况，及时调整。有了它你和运维寿命都会得到持久化。

应用案例：

- [案例一：健康码CPU高案例分析](https://blog.csdn.net/zybank_it/article/details/108585520?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-108585520-blog-124179519.pc_relevant_antiscanv3&spm=1001.2101.3001.4242.3&utm_relevant_index=6#CPU_15)
- [案例二：应用线程连接数异常](https://blog.csdn.net/zybank_it/article/details/108585520?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-108585520-blog-124179519.pc_relevant_antiscanv3&spm=1001.2101.3001.4242.3&utm_relevant_index=6#_39)
- [实战：使用 阿里 Arthas 工具分析 CPU 飙高](https://blog.csdn.net/m0_62051288/article/details/124218596?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-124218596-blog-124179519.pc_relevant_antiscanv3&spm=1001.2101.3001.4242.1&utm_relevant_index=2)

``` text
dashboard展示所有线程、内存、gc

查看最繁忙的线程在执行的线程栈，可以使用 thread -n   （thread -n 8）

jad 使用 jad 命令直接对 HighCPUApplication 类反编译
(可以看到，调用路径是 main->task()->doTask()，当 doTask 方法接收到的 int 参数等于某个常量的时候，会进行 1 万次的 MD5 操作，这就是耗费 CPU 的来源。那么，这个魔法值到底是多少呢？)

表示需要监控耗时超过 100 毫秒的 doTask 方法的入参
watch org.geekbang.time.commonmistakes.troubleshootingtools.highcpu.HighCPUApplication doTask '{params}' '#cost>100' -x 2

最后，我们使用 ognl 命令来运行一个表达式，直接查询 User 类的 ADMIN_ID 静态字段来验证是不是这样，得到的结果果然是 0：


首先，通过 dashboard + thread 命令，基本可以在几秒钟内一键定位问题，找出消耗 CPU 最多的线程和方法栈；
然后，直接 jad 反编译相关代码，来确认根因；
此外，如果调用入参不明确的话，可以使用 watch 观察方法入参，并根据方法执行时间来过滤慢请求的入参。
```



参考：

https://blog.csdn.net/sshduanzhijun/article/details/124373644?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-124373644-blog-124179519.pc_relevant_antiscanv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-6-124373644-blog-124179519.pc_relevant_antiscanv3&utm_relevant_index=11



https://www.zhihu.com/question/395652253/answer/1959672118
